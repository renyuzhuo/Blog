[{"number":57,"title":"2025 新年快乐","created_at":"2024-12-31 11:53:24","body":"![2025](https://github.com/user-attachments/assets/9cde8469-64cb-400d-adf2-dfd4df51fa92)\r\n\r\n**芜湖~~~ 2025 来了。**\r\n\r\n上一次写这种东西，时间还是在 2019.12.13，真的好久了。不记得这几年为啥没写，也没有必要去想了，今天写点什么，聊聊吧。\r\n\r\n回忆这种事情不好玩，该复盘的事情早已复盘过了，剩下的都是历史，没必要再去回顾了。直接做个总结，想想接下来的计划比较有趣。\r\n\r\n**2024** 一些有趣的、异想天开的尝试，一部分夭折了，一部分受到了一些阻碍，一部分还在探索中，整体在稳步推进，这一部分比较平稳但是进度有点慢，需要加快。去没去过的地方看看，也就在今年年初走的算是比较远了，见识到了些没见识过的，剩下的时间里去的地方大同小异，没有带来特别大的冲击。今年微信读书阅读时间比 2023 年下降了 62%，只读了 139 小时，平均下来每天也就二十几分钟，并且差不多一半的时间是在读《西游记》，原因是因为在打黑神话悟空，打不过，就去读书了看看背景故事，实在是惭愧呀。今年在一些事情上的想法和思考，相比之前有了比较大的一些变化，认知上有了些新的角度，我甚至能明显感觉出来看问题的角度和以前有些不同，这是不是有点离谱了，这种东西应该是潜移默化的才对，这不太合理需要警惕。最后，今年还有个特别重要的事情是**结婚了**！单这一件事就足以让 2024 不同寻常。\r\n\r\n**2025** 来了，各种异想天开尝试需要进一步推进，需要优化迭代做些改进，在一个方向上做出些突破性的进展。2025 驾照尽量考下来吧，对，我还没驾照！我都觉得离谱，尽量吧。还有 App Store 上没备案被下架的应用重新上架，在 Play Store 上架一个新应用，采用平时用不到的技术，这是为了立身的技术不要落后，同时在鸿蒙上上架一个工具类的小应用，掌握基础的鸿蒙开发也应该是基本功了。三月份开始做准备，五一再去没去过的地方转转，在过年放假期间商量好行程，更多的旅行计划看情况而定不强求。至于学习方面，2025 重点突破一下英语，我就不信为啥我就搞不明白，同时很好奇是不是英语的笑话都比较尬，研究一下。今年要立的 Flag 是早睡，2025 一定要早睡、早睡、早睡，不要熬夜，看看到底是能坚持几天吧，不出意外这个一定会失败。在运动方面学一项新的技能，已经想好要干啥了，如果能成，我就录个视频发朋友圈装…，不对，是锻炼身体啦。没有其他的计划了，计划太多是会失败的！\r\n\r\n**最后，祝你新年快乐！**"},{"number":55,"title":"【随笔】那年考研","created_at":"2024-02-26 16:33:31","body":"刚刚刷朋友圈，看到了同事在八个小时前，晒出的考研成绩单，上岸的成绩单，配的文字是“...考研狗终于上岸了😭😭😭，不枉我两点睡八点起...”，挺牛的，一边工作一边考研考上了，真挺牛的，恭喜恭喜。\r\n\r\n想起了四年前，大学毕业后，工作了三年的我，也是莫名其妙，鬼使神差的去考研了，也说不清具体的原因，也许是觉得工作没有意义需要去找新的方向，也许是因为工作到了一定的瓶颈需要一些突破的动力，也许是为了积分落户能增加的那一点五分，也许是怀念大学时间那最好的一段生活，或者也许就是太闲了没事找事……至今我也说不清当时究竟是什么原因促使我就去考研了，反正结果就是去考了。\r\n\r\n虽然已经过去几年了，但是印象还是蛮深的，现在仍然能记起很多：早早吃过午饭去教室一学就是一下午，买一个大瓶的饮料庆祝自己想通了一个知识点，到处找空教室想自习却找不到合适的教室，那年 QQ 音乐年终总结被“考研政治肖秀荣精讲精练”霸榜，晚上十一点半顶着大北风和超大的大雪骑车回家，以及晚饭后戴着耳机一边在操场走圈一边一边和女友语音闲聊些什么。历历在目，真的，历历在目！\r\n\r\n那一年考完研回家，便开始了那消逝的三年第一年，那一年我在老家呆了差不多五个月，那是自上大学后在家呆的最长的一年，不过我倒是没有焦虑，可能是工作了几年后成长了吧。后续就是考研成绩发布延期、调剂、复试，一切顺理成章，没有达到报考的学校分数线，调剂其他学校时选择了非全日制，预期之内，按计划进行，只复习两个多月我必须做这样的计划。\r\n\r\n终于告一段落，可以开始找工作了，来到了现在的公司，一边读研一边上班，真的好累，相比较而言，周一到周五算是假期，周六周日上课更累，不过也坚持下来了，也算是一种体验，需要有科研成果来达到毕业要求，发论文、专利，做实验记数据，大论文，当时真的想死！现在想想，周末在学校食堂吃饭真便宜！\r\n\r\n拿毕业证的那天，是一个工作日，中午午休的时间，打了个车去学校，取了毕业证和学位证赶回来，拍了照发给想发的人，都没有耽误下午的工作。心如止水！\r\n\r\n突然又想起，以前工作租房子合租的室友，也是工作后考研读研，应该毕业了吧，我记不起她的名字了，翻了一圈微信联系人才找到，打开她的朋友圈三日可见，是一段视频，分享给你。真好！\r\n\r\n晚安！\r\n\r\n2024.02.27 凌晨于北京"},{"number":53,"title":"基金定投","created_at":"2021-01-07 16:51:38","body":"用数学的方式分析定投的基本原理，如何均摊成本，何时该卖出，不要盲目投资！\r\n\r\n#### 用代码构建数学模型\r\n\r\n```\r\n# 引入依赖\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nimport math\r\n```\r\n\r\n#### 定义基准参数\r\n\r\n```\r\n# 一年 365 天\r\ntime = 365\r\n# 每天定投金额\r\naip = 100\r\n# 波动基准\r\nbase = 2\r\n```\r\n\r\n#### 前提条件\r\n\r\n假设一年之内基金或股票的价格是周期变化的。\r\n\r\n```\r\n# 假设市场在一年内是周期性变化的\r\ndays = np.linspace(0, 2 * np.pi, time)\r\n# 假设某基金或股票以 base 为基准上下波动\r\nprice = np.sin(days) + base\r\n\r\n# 价钱变化\r\nplt.figure()\r\nplt.xlabel(\"Days\")\r\nplt.ylabel(\"Price\")\r\nplt.plot(days, price, color='green')\r\n```\r\n\r\n![波动](https://user-images.githubusercontent.com/7275046/103917144-38f4e200-5148-11eb-83d2-c41d1ee8a9be.png)\r\n\r\n#### 份额确认\r\n\r\n每一天购买份额是变化的，由于价格波动，在价钱低的时候多买，价钱高的时候少买，整体可以拉低成本。\r\n\r\n```\r\n# 假设每天定投 aip 元，每一天购买份额为\r\nshare = aip / price\r\n\r\n# 购买份额变化\r\nplt.figure()\r\nplt.xlabel(\"Days\")\r\nplt.ylabel(\"Share\")\r\nplt.plot(days, share, color='red')\r\n```\r\n\r\n![购买份额](https://user-images.githubusercontent.com/7275046/103917155-3befd280-5148-11eb-8f2d-f8962001958b.png)\r\n\r\n#### 持仓\r\n\r\n可以计算持仓总份额，以及持仓总市值。\r\n\r\n```\r\n# 持仓总份额\r\ntotal_share = np.sum(share)\r\n# 持仓份额市值\r\ntotal_money = total_share * base\r\n\r\n# 输出：持仓份额、持仓市值\r\nprint('Total Share: ', total_share)\r\nprint('Total Money: ', total_money)\r\n# Total Share:  21065.549798502376\r\n# Total Money:  42131.09959700475\r\n```\r\n\r\n#### 收益\r\n\r\n计算定投总成本和总收益。\r\n\r\n```\r\n# 总成本\r\ntotal_cost = aip * time\r\n# 最终收益为最后持仓总额减去成本\r\nbalance = total_money - total_cost\r\n\r\n# 输出：总成本、总收益\r\nprint('Total Cost: ', total_cost)\r\nprint('Total Balance: ', balance)\r\n# Total Cost:  36500\r\n# Total Balance:  5631.099597004752\r\n```\r\n\r\n#### 收益率\r\n\r\n计算收益率，用总盈利除以总成本，不考虑主动调仓等操作，一年的收益率大约是 15.4%。\r\n\r\n```\r\n# 盈利收益率\r\nprint('Ratio: ', balance / total_cost)\r\n# Ratio:  0.1542767012878014\r\n```\r\n\r\n#### 成本变化曲线\r\n\r\n在定投过程中，每一股的平均成本随着每天的定投而变化，一个周期内成本变化曲线。\r\n\r\n```\r\nsum = 0\r\ncosts = []\r\n\r\nfor day in range(0, time):\r\n  # 0..364\r\n  sum = sum + share[day]\r\n  cost = aip * (day + 1) / sum\r\n  # print(cost)\r\n  costs.append(cost)\r\n\r\n# 一年期后最终持仓成本\r\nprint('Last Cost: ', costs[time - 1])\r\n# Last Cost:  1.73268679664819\r\n\r\n# 成本变化\r\nplt.figure()\r\nplt.xlabel(\"Days\")\r\nplt.ylabel(\"Costs\")\r\nplt.plot(days, costs, color='orange')\r\n```\r\n\r\n![成本](https://user-images.githubusercontent.com/7275046/103917158-3c886900-5148-11eb-916e-feb97b0ef932.png)\r\n\r\n#### 对比市场价和持仓成本\r\n\r\n我们把基金或股票的价钱变化曲线（绿线）和由于定投平摊成本导致的成本变化曲线（蓝线）放到一起对比一下。\r\n\r\n```\r\nplt.figure()\r\npl = plt.plot(days, price, color='green')\r\ncl = plt.plot(days, costs, color='blue')\r\nplt.show()\r\n```\r\n\r\n![对比](https://user-images.githubusercontent.com/7275046/103917160-3db99600-5148-11eb-889e-8adda7b7e381.png)\r\n\r\n## 总结\r\n\r\n可以看到，不考虑其他因素，虽然市场价经过符合正弦函数的波动后，但是如果每天都买，总的成本价比市场价还是要低的，卖出则是赚钱的，避免了一次购买择机的风险。经过上面计算，赚钱比例大约为 15%。\r\n\r\n总结起来，如果市场波动符合经济发展规律，定投基本可以保证赚钱。\r\n\r\n更进阶一点：\r\n\r\n  - 穿越多个波动周期，盈利比例不会变好（修改波动周期，增加到一年内两次波动，盈利率保持不变）；\r\n  - 按照上面的波动情况计算，若在较高处及时卖出，一年的收益率大约在 16%，可以增加盈利比例；\r\n  - 在波动处于上升期时，主动减少定投金额，在波动处于下降期时，增加定投金额，更可以提高盈利比例；\r\n  - 若对于经济发展长期有信心，在较低处无脑定投，不用卖出，在较高处及时止盈，则可以有较好的收益。\r\n\r\n## 警告\r\n\r\n市场远比理论模型要复杂，狂跌不止才是真的危险。\r\n\r\n> 别人恐惧我贪婪，别人贪婪我恐惧。\r\n> ——巴菲特\r\n\r\n### Reference\r\n\r\n- [代码地址](https://colab.research.google.com/drive/1g1hL0Qr38Ycgrsc1rZo8KsoPmzKS6rDr?usp=sharing)"},{"number":51,"title":"考研经历吐血总结","created_at":"2020-05-23 15:55:33","body":"## 前言\r\n\r\n考研总算是结束了，现在真的脑壳疼，真的是那种生理上的脑壳痛，睡一觉应该就好了的那种。\r\n\r\n[上一篇](https://github.com/renyuzhuo/Blog/issues/45) 写考研的事情差不多是初试结束后的时间，当时觉得考得不好，但是没有出成绩，简单写的随笔吧，今天确定了录取通知，算是所有的事情都尘埃落定了，剩下调档政审什么的除了麻烦一点不会有什么烦心事了，今天就好好总结一下吧。\r\n\r\n## 考研全过程\r\n\r\n### 决定考研前\r\n\r\n也不知道什么时候，也不知道因为什么原因，就是想搞人工智能了，可能是觉得当时觉得无人驾驶的送快递的小车比较萌萌哒？反正就是一时头脑发热跟我的老板说我想离职，我想去搞智能硬件，我的老板跟我聊了很多，其中提到了如果想搞人工智能要不要去读个研？一语惊醒梦中人呀，可以呀，老板还跟我说公司可以给我一些提供方便，如果完成了任务，可以不用太多的加班，可以考虑在公司不忙的时候或者是休息的时候我可以自己学习，在一些情况下可以考虑给我分配简单一些的任务，总是就是给我创造一个相对好一点的环境去学习，那段时间早上五点我去公司，学习到九点半公司上班，不过白天和晚上还是没有太多的时间去学习，这样子过了两个月吧，觉得太累了，并且就像微积分那种东西，这么学真的有点难，太痛苦了，最后还是跟老板说了 Sorry，我还是决定去疯狂一下，决定工作三年后辞职考研。经过一个月的工作交接，大约在八月下旬的时候从公司离职，纯粹的玩了两天，然后开始正式去复习考研。\r\n\r\n这个过程中感谢那些帮助过我的人，感谢我的老板，谢谢啦！\r\n\r\n### 考研复习阶段\r\n\r\n这一段时间是有一些痛苦的，微积分、线性代数、概率论与数理统计、数据结构、计算机组成原理、政治，还有那让我无论如何都放心不下的英语，真的是想死，想着都脑壳疼。可是没有退路呀，决定要这么干那就只能继续干了，在 GitHub 上和 Google 云端硬盘上稍微做个计划吧。\r\n\r\nGoogle 云端硬盘首先是一个整体的看板，还有多久要考试了，中间有几个重要的时间节点，用公式的方式写好，每天看一眼就知道还有多久考试，每个科目复习用了多长时间，这从整体上有了一个概念，就像下面这样。\r\n\r\n<img width=\"1376\" alt=\"Google 云端硬盘\" src=\"https://user-images.githubusercontent.com/7275046/82733520-ea284280-9d46-11ea-8928-db6d9ab4d721.png\">\r\n\r\n然后每天去附近的一个大学教室去自习，这个学校有个特点是上午的课超级多，下午没什么课，因此我上午去的比较晚，晚上到十一点，说实话，没有觉得很累，算是一个稍微紧绷但是没有用力过度的一个状态吧。\r\n\r\n当然，在对每一科目的复习采用的方式也不是很相同，但是还是要有一个管理的，采用的还是 Google 云端硬盘的方式，大致如下，记录了每天干了点什么，或者是没有进行学习，或者是遇到了什么问题，有什么想法和要做什么调整的。左侧的时间红色代表这一天已经过去了，绿色代表还没有过去，右侧的红色是学习了一些东西，等等吧。\r\n\r\n<img width=\"817\" alt=\"Google 云端硬盘\" src=\"https://user-images.githubusercontent.com/7275046/82733498-d250be80-9d46-11ea-8b3c-d58801d9140d.png\">\r\n\r\nGitHub 上主要是用了项目的管理方式，还有一些检查点的具体内容也记录在了这里。\r\n\r\n<img width=\"1437\" alt=\"GitHub\" src=\"https://user-images.githubusercontent.com/7275046/82733565-31aece80-9d47-11ea-9991-6eba967d2b76.png\">\r\n\r\n中间有那么一两天心烦意乱完全不想学习，但整体来说还可以吧，算是正常吧。这里尤其要说的是他们学校的食堂，真的还挺好吃的，校外还有一个面馆，真的是百吃不厌，还都挺便宜的，这算是解决了一个大问题，如果我在家里复习每天点外卖那估计就完全不同了。我特别想吐槽的是他们学校的操场，临近考试前的一段时间，每天晚饭前我都会去操场走两圈，和朋友聊聊天什么的，但是这个操场的入口大门我居然找了三天！没错，就是找进去的大门，也不知道是谁设计的，需要在一个拐角处还要转两个弯，操场有围栏我就不说什么了，这居然还要把门藏起来，也是人才呀！放一张我拍的其中最喜欢的照片，纪念一下。\r\n\r\n![操场](https://user-images.githubusercontent.com/7275046/82733754-ae8e7800-9d48-11ea-818c-d425ea752933.jpeg)\r\n\r\n还有比较难忘的是每天去学校我要骑自行车，大约二十分钟的路程吧，有下雨的时候，有下大雪的时候，有下雨的时候，还有那种最可怕的狂风，十二月份有时还巨冷，真的是历历在目呀，不知道当时怎么想的，明明可以打车，居然非要跟自己作对，只能说一句当时真的是年少轻狂呀！这里居然没有照片，真的是缺少灵魂了呀。\r\n\r\n还有一点要说的是他们教学楼下的空教室查询系统真的是挺好用的，我本科的时候学校的那个系统我没怎么用过，没想到在其他的学校用上了，有点意思呀！\r\n\r\n就这样每天两点一线的过了不到四个月吧，平平淡淡，没有遇到什么大事，但是心态真的是跌宕起伏。开始时的微积分挺简单，到后面的什么鬼，想疯，再到考试前的懵懵懂懂毫无把握，还是没学好，不过我还是想推荐一下张宇的数学考研指导书，对我帮助还是挺大的。英语从最考试的“这是个啥”，到后来的“应该差不多是个啥”，反正就是一直是最担心的科目。专业课我知道我能过线，但数学和英语占用的时间太多了，没有时间分给它，越到后面越没什么把握，只能尽量多看一点了，但是后来出成绩时我没想到会会比预想的还要低了很多，这可能是我的最失误的地方吧。政治我就尽可能的写，尽可能的背，骑车在路上耳机里放着每章的知识点的音频，真的还是挺有用的，最后政治的成绩比我预期的还要要那么一点点，这一点还是挺开心的。\r\n\r\n对于这种复试的过程，真的是体会过了其中的酸甜苦辣真是一言难尽，只能说一句：你不是我，怎知我走过的路，看过的风景，怎知我心中的乐与苦……\r\n\r\n### 考研初试\r\n\r\n对于这个问题我倒是异常的平静，我不是应届生，因此不能住在宿舍里，回到老家去报名考试，在考场周围定了一个酒店，提前一天到酒店，去考场踩了一下点。考试那两天，候考，安检，考试，异常的平静，真的没有什么想说的，那两天过的真的挺快的。这里有两个小建议，一是如果中午不方便回酒店，可以到钟点房休息一下，二是放轻松，没什么大不了的。\r\n\r\n最后一场考试后，是爸爸妈妈开车去接我的，带着香蕉，我在车上吃了两根，那一天也下雪了，挺小的，路上堵车稍微堵了一会，挺平静的。\r\n\r\n### 结束初试\r\n\r\n结束初试后的那一段时间，妈妈还要上班，我又回到了北京的出租屋内，玩了几天游戏，睡了几天觉，浑浑噩噩过了几天，现在没有什么特别的印象了，好像就是一瞬间就过去了。\r\n\r\n再后来过年了，在家里和妈妈呆了一个寒假，突如其来的新冠疫情打乱了之后所有的计划。我本来计划休息几天然后准备考研复试，结果由于疫情的影响，初试成绩公布延迟，复试延迟，整整推辞了六十天，两个月，这真的是没想到呀没想到！\r\n\r\n武汉封城，全国驰援，开学延期，复工延期，电影院关闭，旅游服务业基本停滞，真的让所有人措手不及，这其中有太多太多，可能永生难忘了……\r\n\r\n### 考研调剂\r\n\r\n很惨，我的第一志愿分数线不够，调剂计算机专业各个学校也都爆炸，挺烦的。我花了几天的时间收集学校的信息，调剂系统我一共报了四个志愿，第一个志愿差一分拒绝了我，第三个志愿把我录取了，第二个志愿本来是我最想去的，但是复试的时间在第三志愿之后，我确认了第三志愿的待录取后第二志愿的复试我拒绝了，第四志愿因为复试时间和第三志愿冲突我放弃了，这么说来其实我志愿选择其实还是可以的，也不枉我花了四天的时间去收集信息，包括学校专业、排名、方向、往年录取分数线、统招人数、调剂名额、复试科目等等，我还是用表格统计出了大约十个学校，从后期报名效果看还是挺好的。\r\n\r\n这里需要说一下我的复试，真的表现得有点差，或者说非常差，至少我自己是这么认为的，也不知道为什么学校就给我过了，1:1.7 的复试比例我这样的不应该过才对，这是我想不通的，这也不应该是我去深究的问题，都结束了。\r\n\r\n接受第三志愿的拟录取或者是拒绝第三志愿等待第二天的第二志愿的复试还让我纠结了一个小时，这是个选择，影响了我未来至少三年的生活，未来三年怎么样完全就在一瞬间改变了，想一想真的是有点神奇的呀，挺有趣的。\r\n\r\n## 后记\r\n\r\n没有什么，只想写下点文字纪念一下我过去十个月的生活。\r\n\r\n愿世界和平！\r\n"},{"number":50,"title":"愿一切安好！","created_at":"2020-04-04 03:48:45","body":"[Hexo 静态博客](https://ai.renyuzhuo.cn) 完整支持特殊日子黑白悼念，愿生者坚强，逝者安息！\r\n\r\n### 方法 1\r\n\r\n静态方法，直接在模板文件中添加 CSS 样式：\r\n\r\n```css\r\n<style>\r\nhtml {\r\n  FILTER: gray;\r\n  -webkit-filter: grayscale(100%);\r\n}\r\n</style>\r\n```\r\n\r\n### 方法 2\r\n\r\n动态方法，可在 _config.yml 中进行配置多个日期：\r\n\r\n```yml\r\ngrieve:\r\n  - '5-12'\r\n  - '9-18'\r\n  - '2020-4-4'\r\n```\r\n\r\n页面模板如 footer.ejs 中：\r\n\r\n```javascript\r\n<script type=\"text/javascript\" src=\"/js/grieve.js\"></script>\r\n<% if (config.grieve) { %>\r\n    <script>\r\n        grieveIfNeed('<%= config.grieve %>')\r\n    </script>\r\n<% } %>\r\n```\r\n\r\n创建 JS 文件 grieve.js 放到 js 文件夹下：\r\n\r\n```javascript\r\ngrieveIfNeed = function (dateList) { \r\n    var date = new Date();\r\n    var year = date.getFullYear();\r\n    var month = date.getMonth() + 1;\r\n    var day = date.getDate();\r\n    var dateArray = dateList.split(',')\r\n    \r\n    for(i = 0; i < dateArray.length; i++){\r\n        if(year + '-' + month +'-' + day === dateArray[i] || month +'-' + day === dateArray[i]){\r\n            var style = document.createElement(\"style\");\r\n            style.type = \"text/css\";\r\n            try{\r\n            　　style.appendChild(document.createTextNode(\"html{FILTER:gray;-webkit-filter:grayscale(100%);}\"));\r\n            }catch(ex){\r\n            　　style.styleSheet.cssText = \"html{FILTER:gray;-webkit-filter:grayscale(100%);}\";\r\n            }\r\n            var head = document.getElementsByTagName(\"head\")[0];\r\n            head.appendChild(style);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 最后\r\n\r\n团结让我们的民族延绵不息，缅怀让我们的英雄永垂不朽！\r\n"},{"number":45,"title":"2019 就要结束了","created_at":"2019-12-23 05:58:37","body":"## 前言\r\n\r\n又好久没有写点什么东西了，和我亲近的人知道，这是因为前一段我突然决定去考研了，工作三年了，突然决定尝试一下决定回学校读书，这是一个冒险，还是一个挺大的冒险。考研需要准备，要考的内容有难度，不容易，准备了还不确定是否能考上，如果考不上，那这个代价就太大了，既中断了工作，又没有学校可以去学习，一切又从头再来，是场赌博，算不上多豪，但是赌本也算是不小。\r\n\r\n今天是初试结束的第一天，还不知道成绩会怎么样，那是一个月之后需要关心的事情，到时候自然会有结论，谨以此文，总结一下我的 2019。\r\n\r\n## 我的 2019\r\n\r\n近些年，每一年都会写点东西，或长或短，或有趣或无聊，或抑郁或欢快，反正都会写点什么，文笔不算好，但是都发布在了当时在用的不同的平台上，今年就写在这里吧。\r\n\r\n今年是我工作的第三年，工作算是按部就班，每天想的也是怎么去写点代码，偶尔想一想听起来很高端的“架构”或“设计”，无波无澜，平平淡淡，春天就是这样过去了。今年的夏天格外的热，气温异常的高，可能是错觉，但是印象中就是这样的，我也不知道想起来了什么，记不清了，反正就跟老板说我想离职，我给的理由是我想去做 AI——人工智能，老板挽留了一下，我相信老板还是蛮喜欢我的，留我也是真心的，我不怀疑这一点，但是对不起了，我还是想走，后来发生了一点预期外的事情，很感谢我的老板，在七月十九号我才结束了最后一天的工作，晚上和同组的同事吃了个饭，我的心静若止水，我就这样离职。离职后和某人玩了一天，休息了一天，就开始我的考研备考阶段，挺麻烦挺累的，那一段的生活不算惬意，但烦心的也只有将要考试的科目，心情还是挺轻松的。在这个过程中，参加了一个好友的婚礼，和室友去吃了一顿饭，偶尔看看视频，没有什么其他的娱乐活动了，被推迟或者取消的活动倒是不少，和好几个人约饭都是考完试再说，小 boos 让我当伴郎却因为考研相关的一点事情被我拒绝了，经常和某人出去玩逛街看电影也都是不存在的，以前经常和妈妈打电话也都被耽搁了，各种各样让生活变得有趣一点的事情都被我延期或抛弃了。备考的生活就是这么单调而乏味。不管怎样，那些都已经过去了，昨天下午五点，这些的一切都算是告一段落了，抬起头看看，似乎 2019 年似乎也要过去了。\r\n\r\n## 能不能考上\r\n\r\n我的心态算是考研的学生中心态比较好的，没有要放弃的念头，偶尔被高数折磨一下，被英语打击一下，也没有让我有什么情绪上太大的波动，一切都是那么正常。说起这，我也不知道究竟是什么原因，自从高考以后，就很少有什么能让我紧张慌张或不安了，存在即合理，任何事情我似乎都觉得没什么大不了的了。\r\n\r\n至于能不能考上，我不知道，我知道的是英语和数学我考的不好，英语不好在预料之中，认为数学考的不好的原因是有几个本应该做出来的题没有做出来，这才是最让人觉得无奈的。这次考试我不觉得英语和政治有那么难，微博上说的不可信，但是我没有考好，或者说没有达到预期也是事实，略觉无奈，等着看结果吧。\r\n\r\n## 结束语\r\n\r\n我的 2019 就这样了，还有一个月就要过年了，今年最大的收获就是在家里的时间比前几年长了好多，自从上了大学，我似乎在家里都没待过这么长的时间，很是内疚，今年陪爸爸妈妈的时间多了一些，他们看到我还是挺开心的，这也就是我今年最大的收获了吧。\r\n\r\n对于 2020 年，我没什么想说的，计划说出来就不灵了！希望一切都好！"},{"number":39,"title":"Mac 系统初上手","created_at":"2018-11-22 12:05:49","body":"# 前言\r\n\r\n换了一个 Mac 电脑，需要配一堆开发环境，想着都烦，但也恰好就趁着这个机会，整理一下 Mac 上的常用软件，尤其对于初上手的、使用 Mac 作为开发环境的开发者，交流分享一下，如此甚好！\r\n\r\n# 开发常用环境\r\n\r\n不管是什么开发者，有些环境或软件都是通用的，如下：\r\n\r\n### Chrome\r\n\r\n[主页地址](https://www.google.com/chrome/)，Safari 和 IE 一样，最大的作用是下载 Chrome！作为一个开发者，不过你是否喜欢，都不得不承认，Chrome 是最好用的的浏览器，那么多的插件都可以通过 [Web Store](https://chrome.google.com/webstore) 下载，Google 不作恶和其开源的特性，都可以最大程度保证你的上网安全。不要犹豫，下载一个 Chrome 吧，用 Chrome 打开本界面，继续配置你的电脑吧！\r\n\r\n### Alfred\r\n\r\n[主页地址](https://www.alfredapp.com/)，Mac 上的神器。每个平台都有一些好用的软件或神器，Alfred 就是 Mac 上的神器之一，[有人介绍过 Alfred 了](https://www.cnblogs.com/chanshuyi/p/the_efficient_app_alfred.html)，可以看一看。\r\n\r\n### JDK\r\n\r\n[主页地址](https://www.oracle.com/technetwork/java/javase/downloads/index.html)，无论你多么喜欢或鄙视 Java，都不得不承认，太多的应用、工具、或者是运行环境都需要用到 Java，作为一个开发者，为了方便以后更好的使用 Mac，还是把 Java 环境装上吧。Java 11 已经不再免费，但是作为个人使用，问题不大。同时作为开发者，如果学习或工作内容与 Java 有关，我还建议安装多个 Java 版本，至少 [Java 8](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) 和 [最新的 Java 运行环境](https://www.oracle.com/technetwork/java/javase/downloads/index.html)。\r\n\r\n### Git\r\n\r\n[主页地址](https://git-scm.com/downloads)，作为开发者，Git 是基本技能，是 [Linus Torvalds](https://en.wikipedia.org/wiki/Linus_Torvalds) 开发的 [版本控制工具](https://en.wikipedia.org/wiki/Git)，如果你对这个不了解，可以得出结论，你还没有入门开发者。以后了解了 Git，也要了解一下 [GitHub](https://github.com/) 网站，同时欢迎你成为一个开发者！\r\n\r\n### Python\r\n\r\n[主页地址](https://www.python.org/downloads/)，Python 已经变成了程序猿的工具，无论你是否是 Python 开发者，平时都免不了写一些脚本，避免那些重复的工作与劳动，Python 并不一定适合所有的情况，但是绝对是大多数情况下的首选工具。如果你还对 Python 不熟悉，建议日后的日子多看看多学习一些，这也是中级程序员进阶之路上必须要掌握的技能。Python 2.x 和 3.x 是不兼容的，真的很蛋疼呀，没什么，我就是想吐槽一下！:-)\r\n\r\n### Sublime Text\r\n\r\n[主页地址](https://www.sublimetext.com/3)，我认为的相当好用的文本编辑器。平时定然会查看或编辑一些纯文本文件，一个好用的编辑器必不可少，Sublime Text 了解一下！\r\n\r\n### Mounty\r\n\r\n[主页地址](https://mounty.app/)，你可能还没有遇到过这样的问题，别人拿来一个移动硬盘，你只能看，无法往里面复制文件。这很可能是因为他的移动硬盘格式是 NTFS，你想给他拷东西，却不能写，好尴尬。Mounty 就能解决这个问题，你总会用到的。\r\n\r\n### The Unarchiver\r\n\r\n[主页地址](https://theunarchiver.com/)，解压缩工具，这个简单好用，你会喜欢的。与 [WinZip](https://www.winzip.com/mac/en/) 配合使用，效果更佳！\r\n\r\n### CdTo\r\n\r\n[主页地址](https://github.com/jbtule/cdto)，Finder 强化工具，用了都说好，对于开发者，经常使用命令行，这个可以鼠标点击后直接在现在的目录下打开命令号，简直完美！建议你试试！\r\n\r\n### WPS\r\n\r\n[主页地址](http://www.wps.cn/product/wpsmac/)，我就不信你没有打开微软 Word，Excel 和 PPT 的需求，WPS 你值得拥有，当然，如果你执意想用 [Office Mac](https://products.office.com/en-us/mac/microsoft-office-for-mac) 版，我也没什么意见，你开心就好！\r\n\r\n### MathPix\r\n\r\n[主页地址](https://mathpix.com/)，如果你需要写论文，从其他地方复制公式，这个就是最高效的利器。\r\n\r\n## 其他软件\r\n\r\n[QQ](http://im.qq.com/macqq/)，[微信](https://weixin.qq.com/)，[钉钉](https://www.dingtalk.com/)(工作常用的通讯工具)。[Foxmail](https://www.foxmail.com/mac/)(好用的邮件客户端)。[百度网盘](https://pan.baidu.com)，[有道词典](https://itunes.apple.com/cn/app/you-dao-ci-dian/id491854842?mt=12)，[SourceTree](https://www.sourcetreeapp.com/)，[VS Code](https://code.visualstudio.com/)，[Postman](https://www.getpostman.com/)，[QQ 音乐](https://y.qq.com/)，[网易云音乐](https://music.163.com/)，[XCode](https://developer.apple.com/xcode/)，[Charles](https://www.charlesproxy.com/)，[有道云笔记](https://note.youdao.com/)，[腾讯视频](https://v.qq.com/)，[爱奇艺](https://www.iqiyi.com/)，[优酷](http://www.youku.com/)，[Jetbrains 套装](https://www.jetbrains.com/)等\r\n"},{"number":32,"title":"【用 Kotlin 写 Android】用 Kotlin 写 Hello World","created_at":"2018-04-20 18:50:41","body":"## 写在前面\r\n\r\n这篇文章题目叫“【用 Kotlin 写 Android】用 Kotlin 写 Android Hello World”，主要介绍一用 Kotlin 写出来的 Hello World 究竟与用 Java 写有什么区别，并会介绍一些概念和 Kotlin 的具体实现。\r\n\r\n#### 技术点分析\r\n\r\n一个控件定义后，在代码中不需要通过 findViewById 来讲程序对象和 xml 中布局绑定起来，而是可以直接使用使用 xml 中控件 id 直接操纵控件，这个时候会提示引入 `import kotlinx.android.synthetic.main.activity_main.*` 的依赖，这样可以说相当方便，去除了那些没什么大意义的模板代码，减少代码量，使结构更清晰。相信你已经看过很多地方介绍 Kotlin 都会说这是它很大的一个优点，但我想说的还包括：如果你在 `setContentView(R.layout.activity_main)` 中加载了一个布局文件，但是你在下面使用布局文件中 id 直接去操纵控件时，id 写错了，写成了一个在 `activity_main` 中根本不存在的一个 ID，会不会有问题？答案是会挂掉，可以理解，操作了不属于自己界面的元素，会报 Crash：`Attempt to invoke virtual method * on a null object reference`；那如果两个界面 id 一致，但是在 `import` 时写错包了，会有问题吗？经试验，是没有问题的，这是不是很奇怪？其实这是因为 Android 中，在 R 文件中将资源文件都映射成一个 `int` 整数，存储在不同 R 文件的静态内部类里面，因此两个 id 其实在 R 文件中用一个值表示了。同理，如果其他的一些资源文件被同样映射，即使写错了，也可能正常运行。PS：不过一般没有理由把这个写错。\r\n\r\n我们通过 id 可以找到对应的 View，为什么在 Java 中就不可以呢？这个 include 就是怎么完成这个的呢？答案是这个 include 不仅仅是简单的 include，而是因为在 build.gradle 加入了扩展 plugin: `kotlin-android-extensions`，而这个扩展 plugin 其实是会编译生成一些额外代码的，那我们就把编译出来字节码文件进行反编译，看看反编译出来了点什么：\r\n\r\n![反编译 Kotlin 生成的字节码](https://user-images.githubusercontent.com/7275046/39064906-b0baf6ee-4502-11e8-977a-ac44b8a27d78.png)\r\n\r\n再对比一下源文件：\r\n\r\n![源文件](https://user-images.githubusercontent.com/7275046/39064960-d8b94286-4502-11e8-9d8c-1e15fc69b307.png)\r\n\r\n我们可以看到：setContentView(2131296283)，将 2131296283 转换成十六进制是 0x7f09001b，在 R 文件中：\r\n\r\n```\r\npublic static final class layout {\r\n  public static final int activity_main=0x7f09001b;\r\n}\r\n```\r\n\r\n同时也不存在直接用 id 直接操作 View，而是也通过 findViewById() 来获取 View，并且这里还有一个 HashMap 进行优化，并且 id.my_app_text 也是 R 文件中的，因此在源文件中 import 错文件也不会报错：\r\n\r\n```\r\npublic View _$_findCachedViewById(int var1) {\r\n   if (this._$_findViewCache == null) {\r\n      this._$_findViewCache = new HashMap();\r\n   }\r\n\r\n   View var2 = (View)this._$_findViewCache.get(var1);\r\n   if (var2 == null) {\r\n      var2 = this.findViewById(var1);\r\n      this._$_findViewCache.put(var1, var2);\r\n   }\r\n\r\n   return var2;\r\n}\r\n```\r\n\r\n我们还看到 `println(testNull?.length)` 最后被反编译出来是：`System.out.println(var3);`，在 Kotlin 标准库中 println 的定义是：\r\n\r\n```\r\n/** Prints the given message and newline to the standard output stream. */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun println(message: Any?) {\r\n    System.out.println(message)\r\n}\r\n```\r\n\r\n因此也就是一些边准库的简单写法，在编译后恢复成了正常 Java 代码的写法。我们接着看反编译出来的下半部分：\r\n\r\n![反编译下班半分截图](https://user-images.githubusercontent.com/7275046/39065577-d187811a-4504-11e8-97f4-377e9eeeaa05.png)\r\n\r\n这里有静态类 MainActivity.Companion，对应的是 Kotlin 中的伴随对象，伴随对象内的变量是所有类共用的属性，类似于 static 的含义，在反编译后的代码看，也确实是用 static final 对象实现的：`public static final MainActivity.Companion Companion = new MainActivity.Companion((DefaultConstructorMarker)null);`\r\n\r\n我们还注意到：`val TAG: String? = MainActivity::class.simpleName` 最后被反编译后的代码是：`private static final String TAG = Reflection.getOrCreateKotlinClass(MainActivity.class).getSimpleName();`，Reflection 是反射的意思，由 Kotlin 类映射到 Java 对象。在写前一段代码后会报警告说需要引入 `org.jetbrains.kotlin:kotlin-reflect:1.2.31`，这里我们知道其实了其实它最后用到了 Kotlin 类 Reflection 和方法，不引入包就会报 `kotlin.jvm.KotlinReflectionNotSupportedError: Kotlin reflection implementation is not found at runtime. Make sure you have kotlin-reflect.jar in the classpath` 的错误也就可以理解了。\r\n\r\n最后我们看一下：\r\n\r\n```\r\nvar testNull: String? = null\r\nprintln(testNull?.length)\r\n\r\nvar testNull: String? = \"213\"\r\nprintln(testNull?.length)\r\n\r\nvar testNull: String? = null\r\nif ((System.currentTimeMillis() % 2) == 0L) {\r\n    testNull = \"123\"\r\n} else {\r\n    testNull = null\r\n}\r\nprintln(testNull?.length)\r\n```\r\n\r\n最后被编译成：\r\n\r\n```\r\nString testNull = (String)null;\r\nObject var3 = null;\r\nSystem.out.println(var3);\r\n\r\nString testNull = \"213\";\r\nInteger var3 = testNull.length();\r\nSystem.out.println(var3);\r\n\r\nString testNull = (String)null;\r\nif (System.currentTimeMillis() % (long)2 == 0L) {\r\n   testNull = \"123\";\r\n} else {\r\n   testNull = (String)null;\r\n}\r\nInteger var3 = testNull != null ? testNull.length() : null;\r\nSystem.out.println(var3);\r\n```\r\n\r\n有一定的优化，如果在编译时就能确定值，直接简化，否则就是正常转换，其中 `?.` 最后其实就是转换成了 `if != null` 的判断。\r\n\r\n还有一个知识点是 Lambdas 表达式其实依旧是还原成最基本的 Java 代码，也包含 `new OnClickListener`。\r\n\r\n## 总结一下\r\n\r\n到这里，我们展示了一个最简单的 Hello World 程序，可以看出因为 Kotlin 也是运行在 JVM 上的，因此也需要符合字节码规范，因此反编译后生成的代码就会和直接用 Java 写有很多相似的部分，只不过直接写 Kotlin 的时候，Kotlin 插件或者是库帮我们完成了一些工作，我们接下来一些东西还会类似去分析。\r\n\r\n---\r\n如果有一天你觉得过的舒服了，你就要小心了！欢迎关注我的公众号：我是任玉琢\r\n\r\n![qrcode_for_gh_45402a07f7d9_258](https://user-images.githubusercontent.com/7275046/37878351-56acaf0c-309a-11e8-8d8d-10255972a59f.jpg)"},{"number":31,"title":"【用 Kotlin 写 Android】Kotlin Koans 深入分析讲解（下）","created_at":"2018-04-12 19:06:48","body":"上一篇文章我们介绍了集合类的使用，都是一些方法，这一章包括了前面学习到的东西的一些使用和一些其他琐碎的知识点，我们一个一个看。\r\n\r\n### Task 28：Compound tasks\r\n\r\n![Compound tasks](https://user-images.githubusercontent.com/7275046/38631790-55dc6ba2-3ded-11e8-841a-35c0575ead41.png)\r\n\r\n本题目是前面学到的那些东西的一个汇总使用：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38631792-564fe05a-3ded-11e8-8920-ba828c074535.png)\r\n\r\n### Task 29：Get used to new style\r\n\r\n![Get used to new style](https://user-images.githubusercontent.com/7275046/38632431-52445034-3def-11e8-9f7c-197941382826.png)\r\n\r\n对照 Java 代码改写：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38632434-5416ef20-3def-11e8-8bfb-e4e8bab37a6d.png)\r\n\r\n### Task 30：Properties\r\n\r\n![30：Properties](https://user-images.githubusercontent.com/7275046/38632606-d3f190ce-3def-11e8-9446-f0e66afac1ab.png)\r\n\r\n属性赋值：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38632608-d474d9d4-3def-11e8-9cc0-7d49f960bc2b.png)\r\n\r\n### Task 31：Lazy property\r\n\r\n![Lazy property](https://user-images.githubusercontent.com/7275046/38632792-5094a83c-3df0-11e8-9230-ec4e74f053ce.png)\r\n\r\n只可以赋值一次的属性，一定有标记或变量判断，如果赋值过就不赋值，否则就赋值：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38632945-ca0b6994-3df0-11e8-9857-6640e882fbd0.png)\r\n\r\n### Task 32：Delegates example\r\n\r\n![Delegates example](https://user-images.githubusercontent.com/7275046/38692525-8b8832a8-3eb6-11e8-8596-8883122b8881.png)\r\n\r\nLazy 的委托属性 Delegates，主要是通过委托模式，减少样板代码，还可以实现继承一样的效果。这一个问题比较复杂，我们以后专题分析。\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38692682-20727ebe-3eb7-11e8-9305-2438db102e49.png)\r\n\r\n### Task 33：Delegates\r\n\r\n![Delegates](https://user-images.githubusercontent.com/7275046/38692795-83b8f6ec-3eb7-11e8-92a5-fd61c71dadfe.png)\r\n\r\n委托，我们还是放到后面介绍，这里只要知道有这么一个概念就好了。\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38692948-fad59c8a-3eb7-11e8-8421-9679d71534d7.png)\r\n\r\n### Task 34：Extension function literals\r\n\r\n![Extension function literals](https://user-images.githubusercontent.com/7275046/38693093-79562548-3eb8-11e8-8e3f-709d020386f4.png)\r\n\r\n直接对字面值进行扩展，这是一个很方便的特性，可以让代码简单易懂。\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38693094-79d76626-3eb8-11e8-884f-07ae4720fc08.png)\r\n\r\n### Task 35：String and map builders\r\n\r\n![String and map builders](https://user-images.githubusercontent.com/7275046/38693246-e7614bf8-3eb8-11e8-9a3a-3b8a2d6144a7.png)\r\n\r\n扩展函数字面值可以很有效的用于建造者模式：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38694124-684b4bfe-3ebb-11e8-93d8-fc241839adb3.png)\r\n\r\n其实我们这里还可以写成泛型：\r\n\r\n![答案 2](https://user-images.githubusercontent.com/7275046/38694228-a3a8b060-3ebb-11e8-8006-350dcd4a76c6.png)\r\n\r\n### Task 36：The function apply\r\n\r\n![The function apply](https://user-images.githubusercontent.com/7275046/38694612-b35f88d4-3ebc-11e8-96b0-8babc628e11f.png)\r\n\r\n简化写法：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38694576-9d154c1c-3ebc-11e8-9ac9-2f81230fb094.png)\r\n\r\n### Task 37：Html builder\r\n\r\n![Html builder](https://user-images.githubusercontent.com/7275046/38694859-55c7ca32-3ebd-11e8-86e2-50ea6fd4cf2f.png)\r\n\r\n虽然我们是用 Kotlin 写 Android，但是这个联系中最后还是出了一个创建 Html 的小练习题，我们不妨看一下 Kotlin 定义函数，定义操作符，处理数据的能力，确实是很强大！Java 需要小心了！\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38694861-5687fe88-3ebd-11e8-94fa-9c3863f16346.png)\r\n\r\n### Task 38：Builders: how it works\r\n\r\n我们简单看一下就好了，分析起来篇幅较长，且对于写 Android 用处有限，暂时不做具体分析，在高级应用中在介绍。\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38695287-6f44d9cc-3ebe-11e8-9c25-8cd6e0630091.png)\r\n\r\n### Task 39：Generic functions\r\n\r\n![Generic functions](https://user-images.githubusercontent.com/7275046/38695424-c5f310ea-3ebe-11e8-98ed-3a0db2a0c27c.png)\r\n\r\n泛型函数在标准库中有大量使用，可以极大减少代码量并提供强大功能，在开发一些 SDK 时，比较适用。但是想写好，也是比较困难，需要代码有良好的设计和良好的代码思维。\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38695631-695d71e4-3ebf-11e8-98cb-7f7085779b55.png)\r\n\r\n# 小结\r\n\r\n到这里我们就分析完了 Kotlin Koans 的每个小题，在开始阶段和集合相关内容上，介绍的更详细具体，在后面一些高级使用或不常用并没有用大量篇幅去介绍。这也考虑到现阶段详细介绍，可能不是很好看懂，也用处不大。到这里，我们其实还没有真正开始【用 Kotlin 写 Android】，但有了这些基础，对我们理解代码和写出更简单高效的代码是极有好处的。在后面的文章中，用多个项目将 Android 开发的知识点组织起来，也介绍一些用 Kotlin 写 Android 可能遇见的问题。\r\n\r\n---\r\n如果有一天你觉得过的舒服了，你就要小心了！欢迎关注我的公众号：我是任玉琢\r\n\r\n![qrcode_for_gh_45402a07f7d9_258](https://user-images.githubusercontent.com/7275046/37878351-56acaf0c-309a-11e8-8d8d-10255972a59f.jpg)\r\n"},{"number":29,"title":"【用 Kotlin 写 Android】Kotlin Koans 深入分析讲解（中）","created_at":"2018-04-10 18:29:50","body":"继续接着上一篇我们介绍的，我们继续深入学习 Kotlin Koans。\r\n\r\n### Task 20：Introduction\r\n\r\n接下来的 Task，都是围绕集合展开的，Kotlin 的集合和 Java 的集合差不多，不过 Kotlin 扩展了许多有用的方法。我们先看一下 Show 类的定义：\r\n\r\n```\r\ndata class Shop(val name: String, val customers: List<Customer>)\r\n\r\ndata class Customer(val name: String, val city: City, val orders: List<Order>) {\r\n    override fun toString() = \"$name from ${city.name}\"\r\n}\r\n\r\ndata class Order(val products: List<Product>, val isDelivered: Boolean)\r\n\r\ndata class Product(val name: String, val price: Double) {\r\n    override fun toString() = \"'$name' for $price\"\r\n}\r\n\r\ndata class City(val name: String) {\r\n    override fun toString() = name\r\n}\r\n```\r\n\r\n![20：Introduction](https://user-images.githubusercontent.com/7275046/38569916-230ec5c2-3d1f-11e8-834f-d6ec7737a559.png)\r\n\r\n比较容易，直接用 Shop 中的 customers 转换成 Set 就可以了：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38570022-6012e3d6-3d1f-11e8-817b-28c424963f3f.png)\r\n\r\n### Task 21：Filter; map\r\n\r\n![Filter; map](https://user-images.githubusercontent.com/7275046/38570118-a39fabca-3d1f-11e8-941d-908fff711973.png)\r\n\r\n其中我们可以看到 map 方法是：对于给定的规则，返回 List：\r\n\r\n```\r\n/**\r\n * Returns a list containing the results of applying the given [transform] function\r\n * to each element in the original collection.\r\n */\r\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\r\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\r\n}\r\n\r\n/**\r\n * Applies the given [transform] function to each element of the original collection\r\n * and appends the results to the given [destination].\r\n */\r\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\r\n    for (item in this)\r\n        destination.add(transform(item))\r\n    return destination\r\n}\r\n```\r\n\r\n对于 filter 方法是：返回符合给定规则的 List，规则用于判定该元素是否符合要求，规则返回值为 Boolean\r\n\r\n```\r\n/**\r\n * Returns a list containing only elements matching the given [predicate].\r\n */\r\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\r\n    return filterTo(ArrayList<T>(), predicate)\r\n}\r\n\r\n/**\r\n * Appends all elements matching the given [predicate] to the given [destination].\r\n */\r\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\r\n    for (element in this) if (predicate(element)) destination.add(element)\r\n    return destination\r\n}\r\n```\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38570346-35867ae6-3d20-11e8-947e-d3ea1805c46c.png)\r\n\r\n### Task 22：All, Any and other predicates\r\n\r\n![All, Any and other predicates](https://user-images.githubusercontent.com/7275046/38570853-66bd1312-3d21-11e8-9864-a0515fd43f0c.png)\r\n\r\n有了上面的经验，这里的问题就好解决了：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38570993-d35e60ca-3d21-11e8-9f51-9d10f1b03df1.png)\r\n\r\n根据名称，我们其实可以很容易猜到是干什么，但是我们这里还是要看看其中具体是怎么实现的：\r\n\r\n```\r\n/**\r\n * Returns `true` if all elements match the given [predicate].\r\n */\r\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\r\n    if (this is Collection && isEmpty()) return true\r\n    // 有一个不符合条件，就返回 false\r\n    for (element in this) if (!predicate(element)) return false\r\n    return true\r\n}\r\n\r\n/**\r\n * Returns `true` if at least one element matches the given [predicate].\r\n */\r\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\r\n    if (this is Collection && isEmpty()) return false\r\n    // 有符合条件的，就返回 true\r\n    for (element in this) if (predicate(element)) return true\r\n    return false\r\n}\r\n\r\n/**\r\n * Returns the number of elements matching the given [predicate].\r\n */\r\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\r\n    if (this is Collection && isEmpty()) return 0\r\n    var count = 0\r\n    // 有符合条件的，计数加一，最后返回计数\r\n    for (element in this) if (predicate(element)) count++\r\n    return count\r\n}\r\n\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\r\n    return firstOrNull(predicate)\r\n}\r\n/**\r\n * Returns the first element matching the given [predicate], or `null` if element was not found.\r\n */\r\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\r\n    // 有符合条件的，返回符合条件的这一项\r\n    for (element in this) if (predicate(element)) return element\r\n    return null\r\n}\r\n```\r\n\r\n### Task 23：FlatMap\r\n\r\n![FlatMap](https://user-images.githubusercontent.com/7275046/38571210-74632bf4-3d22-11e8-9e93-cc31a76003fd.png)\r\n\r\nFlatMap 对集合中的元素去重组成新的集合：\r\n\r\n```\r\n/**\r\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\r\n */\r\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\r\n    return flatMapTo(ArrayList<R>(), transform)\r\n}\r\n/**\r\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\r\n */\r\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\r\n    // 遍历集合中元素，把元素的去重后重组成 List 返回\r\n    for (element in this) {\r\n        val list = transform(element)\r\n        destination.addAll(list)\r\n    }\r\n    return destination\r\n}\r\n```\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38571462-27e4cade-3d23-11e8-9955-ce52fb180f96.png)\r\n\r\n### Task 24：Max; min\r\n\r\n![](https://user-images.githubusercontent.com/7275046/38572558-fbe3acc2-3d25-11e8-86af-7fbc887ce15f.png)\r\n\r\n最大最小的查找是比较常用的操作，结合前面的 FlatMap，可以解决此问题：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38572525-dffed3b0-3d25-11e8-845f-4009b0d5eb2d.png)\r\n\r\n其中我们看看 max 是如何实现的：\r\n\r\n```\r\n/**\r\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\r\n */\r\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\r\n    val iterator = iterator()\r\n    if (!iterator.hasNext()) return null\r\n    var maxElem = iterator.next()\r\n    var maxValue = selector(maxElem)\r\n    // 简单粗暴遍历查找符合条件的最大的一项，是稳定的\r\n    while (iterator.hasNext()) {\r\n        val e = iterator.next()\r\n        val v = selector(e)\r\n        if (maxValue < v) {\r\n            maxElem = e\r\n            maxValue = v\r\n        }\r\n    }\r\n    return maxElem\r\n}\r\n```\r\n\r\n### Task 24：Sort\r\n\r\n![Sort](https://user-images.githubusercontent.com/7275046/38572836-d59aad6c-3d26-11e8-9bd6-de12c5a4a581.png)\r\n\r\n排序：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38572837-d60b04ae-3d26-11e8-8480-a574688bda52.png)\r\n\r\n看似简单，不过似乎有没那么简单：\r\n\r\n```\r\n/**\r\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\r\n */\r\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\r\n    return sortedWith(compareBy(selector))\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\r\n    if (this is Collection) {\r\n       if (size <= 1) return this.toList()\r\n       @Suppress(\"UNCHECKED_CAST\")\r\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\r\n    }\r\n    return toMutableList().apply { sortWith(comparator) }\r\n}\r\n\r\n/**\r\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\r\n        Comparator { a, b -> compareValuesBy(a, b, selector) }\r\n\r\n/**\r\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\r\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\r\n * The result of comparison of these [Comparable] instances is returned.\r\n */\r\n@kotlin.internal.InlineOnly\r\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\r\n    return compareValues(selector(a), selector(b))\r\n}\r\n\r\n/**\r\n * Compares two nullable [Comparable] values. Null is considered less than any value.\r\n */\r\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\r\n    if (a === b) return 0\r\n    if (a == null) return -1\r\n    if (b == null) return 1\r\n\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    return (a as Comparable<Any>).compareTo(b)\r\n}\r\n\r\n/**\r\n * Returns a list of all elements sorted according to the specified [comparator].\r\n */\r\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\r\n    if (this is Collection) {\r\n       if (size <= 1) return this.toList()\r\n       @Suppress(\"UNCHECKED_CAST\")\r\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\r\n    }\r\n    return toMutableList().apply { sortWith(comparator) }\r\n}\r\n```\r\n\r\n### Task 25：Sum\r\n\r\n![Sum](https://user-images.githubusercontent.com/7275046/38573240-ffa451fc-3d27-11e8-9c7b-b2a5d87bbf7b.png)\r\n\r\n求和：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38573242-000255a4-3d28-11e8-95c5-241772558115.png)\r\n\r\n```\r\n/**\r\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\r\n */\r\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\r\n    var sum: Double = 0.0\r\n    // 遍历并相加\r\n    for (element in this) {\r\n        sum += selector(element)\r\n    }\r\n    return sum\r\n}\r\n```\r\n\r\n### Task 26：Group By\r\n\r\n![Group By](https://user-images.githubusercontent.com/7275046/38573353-66fb23f8-3d28-11e8-8a60-fdf805b9268d.png)\r\n\r\n分组：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38573445-aaacc250-3d28-11e8-880f-eb559711ffef.png)\r\n\r\n实现方法：\r\n\r\n```\r\n/**\r\n * Groups elements of the original collection by the key returned by the given [keySelector] function\r\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\r\n *\r\n * The returned map preserves the entry iteration order of the keys produced from the original collection.\r\n *\r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\r\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\r\n}\r\n\r\n/**\r\n * Groups elements of the original collection by the key returned by the given [keySelector] function\r\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\r\n *\r\n * @return The [destination] map.\r\n *\r\n * @sample samples.collections.Collections.Transformations.groupBy\r\n */\r\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\r\n    for (element in this) {\r\n        val key = keySelector(element)\r\n        // 将新数据添加到 Map 中，如果以前有 Key，添加，否则创建后添加\r\n        val list = destination.getOrPut(key) { ArrayList<T>() }\r\n        list.add(element)\r\n    }\r\n    return destination\r\n}\r\n\r\n/**\r\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\r\n * puts its result into the map under the given key and returns it.\r\n *\r\n * @sample samples.collections.Maps.Usage.getOrPut\r\n */\r\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\r\n    val value = get(key)\r\n    // 在 Map 中根据 Key 判断是否可以找到 Value，如果找不到，在这个 Map 中创建一条\r\n    return if (value == null) {\r\n        val answer = defaultValue()\r\n        put(key, answer)\r\n        answer\r\n    } else {\r\n        value\r\n    }\r\n}\r\n```\r\n\r\n### Task 27：Partition\r\n\r\n![Partition](https://user-images.githubusercontent.com/7275046/38574040-5d3bc1ea-3d2a-11e8-8c04-678433d3183c.png)\r\n\r\n区分（满足条件和不满住条件）：\r\n\r\n![答案 1](https://user-images.githubusercontent.com/7275046/38574411-53ae160e-3d2b-11e8-9163-51d8be37add6.png)\r\n\r\n![答案 2](https://user-images.githubusercontent.com/7275046/38574615-d2d20940-3d2b-11e8-97e7-7de44c3f3c58.png)\r\n\r\n```\r\n/**\r\n * Splits the original collection into pair of lists,\r\n * where *first* list contains elements for which [predicate] yielded `true`,\r\n * while *second* list contains elements for which [predicate] yielded `false`.\r\n */\r\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\r\n    val first = ArrayList<T>()\r\n    val second = ArrayList<T>()\r\n    // 判断是否满足条件，分别放到第一个第二个参数中\r\n    for (element in this) {\r\n        if (predicate(element)) {\r\n            first.add(element)\r\n        } else {\r\n            second.add(element)\r\n        }\r\n    }\r\n    return Pair(first, second)\r\n}\r\n```\r\n\r\n### Task 28：Fold\r\n\r\n![Fold](https://user-images.githubusercontent.com/7275046/38575238-8dafcf62-3d2d-11e8-9d36-72ef1a3c9a98.png)\r\n\r\n聚合（Fold），思路是：找出所有商品，将这些商品依次和每一个用户买过的商品做交集，最后剩下的商品就是所有用户都购买了的商品：\r\n\r\n![答案](https://user-images.githubusercontent.com/7275046/38575139-443f6f18-3d2d-11e8-93b4-7f114469ebb1.png)\r\n\r\n```\r\n/**\r\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\r\n */\r\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\r\n    var accumulator = initial\r\n    for (element in this) accumulator = operation(accumulator, element)\r\n    return accumulator\r\n}\r\n```\r\n\r\n# 小结\r\n\r\n到这里，我们完成了集合类相关的测试，我们可以看到，集合的基本数据结构，Kotlin 和 Java 区别不大，但是 Kotlin 扩展了集合的方法，这些方法的灵活应用，可以基本满足平时集合相关的操作。要想更灵活的应用，需要我们多加练习，更好的去熟悉。\r\n\r\n---\r\n如果有一天你觉得过的舒服了，你就要小心了！欢迎关注我的公众号：我是任玉琢\r\n![qrcode_for_gh_45402a07f7d9_258](https://user-images.githubusercontent.com/7275046/37878351-56acaf0c-309a-11e8-8d8d-10255972a59f.jpg)\r\n"},{"number":27,"title":"【用 Kotlin 写 Android】Kotlin Koans 深入分析讲解（上）","created_at":"2018-04-08 17:40:27","body":"# 前言\r\n\r\n具体 Kotlin 是什么？我相信你已经在网络上其他地方看到过解释，这里不再赘述，简单一句话：“Kotlin 是一种与 Java、C++ 平级的函数式编程语言”。在上一篇文章中，我们应该看到了，Kotlin 有很多的基础特殊的语法，让代码变得简单清晰 (可能在开始的时候你反而觉得变得复杂了)，但 Kotlin 真的就是语法的改变吗？花两个小时看看 Kotlin 的语法就算学完了 Kotlin 吗？非也！Kotlin 与 Java 最大的区别是 Kotlin 的函数式编程，这一点以后我们会经常提到，Kotlin 的核心与 Java 就有本质的不同。Kotlin Koans 是学习 Kotlin 极好的学习资料，我们先把 Kotlin Koans 做一遍，相信你会对 Kotlin 有完全不同的认识。\r\n\r\n# Kotlin Koans 项目详解\r\n\r\nKotlin Koans 是一个 Kotlin 学习的教程，采用的方式是给你未完成的代码，给你一点提示，你去补全代码，运行单元测试，通过后进入下一题，可以非常好的学习 Kotlin。\r\n\r\nKotlin Koans 的安装，可以在 GitHub 上下载源代码项目，但是我不建议这样做，我建议的方式是安装 [EduTools 插件](http://kotlinlang.org/docs/tutorials/koans.html)，安装方式是直接在插件中心中搜索 EduTools 就可以了：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38205804-77f359cc-36da-11e8-83d5-89d40223feb9.png)\r\n\r\n然后重启 Android Studio。可以看到第一项 Browse Courses：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38205945-1289c1c4-36db-11e8-9966-5f8386ea45b2.png)\r\n\r\n点击选择 Kotlin Koans 项目：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38205952-1ddf64ca-36db-11e8-8e0e-c66287721f5e.png)\r\n\r\n大约需要一分钟后，会创建项目：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38206035-70ee1026-36db-11e8-8ee8-e9eb81b158d3.png)\r\n\r\n感觉提示，完成第一个任务：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38206112-bfc27df4-36db-11e8-9e3d-fc36fe3b7e6f.png)\r\n\r\n这个任务就是上一篇中函数的定义相关的内容，我们可以看到得到如下一些信息：\r\n\r\n  1. Kotlin 文件后缀为 `.kt`\r\n  2. Kotlin 文件不需要定义类，可以直接定义方法\r\n  3. 简单的方法可以省略大括号，直接在 `=` 后写返回值\r\n\r\n# 每一个 Task 详解\r\n\r\n### Task 2：Java to Kotlin conversion\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38206481-20036218-36dd-11e8-86bb-b90fe7124e53.png)\r\n\r\n将 Java 代码转换成 Kotlin 写法。我们打开 `JavaCode.java` 文件，选中 toJSON 方法，复制，到 `Task.kt` 中粘贴(粘贴需要选中代码)，粘贴后可以发现 Java 代码自动转换成了 Kotlin 代码，很方便。\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38206362-bd5782f2-36dc-11e8-9d79-09e51fb00bff.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38206361-bcf44476-36dc-11e8-9847-2981eabf5089.png)\r\n\r\n除了上面这种方法，还可以用 Android Studio 中代码装换工具，将 Java 文件转换成 Kotlin：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38206590-9287b686-36dd-11e8-82c2-f8c9fffa4537.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38206561-6f63f1d8-36dd-11e8-9d05-e1745e526084.png)\r\n\r\n我们在这里注意几个问题：\r\n\r\n  1. 函数的定义，用 fun 关键字\r\n  2. 参数先写参数名，再写参数类型，中间用冒号 `:` 分割\r\n  3. 方法参数后和大括号中间需要写函数返回值类型，用 `:` 说明\r\n  4. 创建对象没有 `new` 关键字，直接类名后跟括号创建新对象\r\n  5. 属性定义用 val(不可更改) 或 var(可以更改)\r\n\r\n### Task 3：Named arguments\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38206965-df5cb32a-36de-11e8-96b5-7dfc67bd60da.png)\r\n\r\nKotlin 中参数是可以有默认值的，并且在调用的时候，可以显示声明哪些变量用哪些值，而不一定必须要按顺序赋值，其他的值使用默认值，很方便灵活，这样就可以减少构造函数、重载函数的数量。Java 中两个重载函数参数的类型如果都一样的话，是不允许的，但是 Kotlin 使用默认值的方式就可以很好的避免这个问题（声明一个三个参数的方法，并加上默认值，调用的时候对不同的参数进行声明赋值，就可以达到 Java 需要多个不同类型从在才能达到的目的）。\r\n\r\n```\r\n/**\r\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\r\n *\r\n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\r\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\r\n */\r\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\r\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\r\n}\r\n```\r\n![图片](https://user-images.githubusercontent.com/7275046/38206969-e1d27284-36de-11e8-925e-adfb90487b8f.png)\r\n\r\n### Task 4：Default arguments\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38207724-58d9a90e-36e1-11e8-8c38-1e1d9b950787.png)\r\n\r\n看题目可以看出，有些方法在调用的时候报错，提示有些值没有别赋值，那我们的任务就是在函数定义的时候加上合适的默认值，分析提示给出的 Java 代码，我们可以看到，最后一个如果 number 没有被赋值，会用默认值 42 调用第二个方法，而第二个方法 toUpperCase 没有被赋值，使用默认值 false 调用第一个方法，则可以写出答案：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38207726-59ae75da-36e1-11e8-8487-0fb46ed47a80.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38207727-5a790110-36e1-11e8-9a1e-d832d43e9021.png)\r\n\r\n在这里我们可以看到合理的使用默认值，可以极大的简化代码。\r\n\r\n### Task 5：Lambdas\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38208268-0b78c260-36e3-11e8-837e-63e7887ef70f.png)\r\n\r\n找偶数很简单，每一个都分别除 2 看余数是否为 0，但是刚刚看到这道问题可能会摸不着头脑，怎么写，这什么意思呀？题目名称叫 Lambdas，Java 8 中支持 Lambda 表达式，Kotlin 也同样支持，怎么写呢。如果想解决这个问题，我们最好解决几个概念：\r\n\r\n  - 函数在 Kotlin 中是一等公民（First-class function）\r\n    - 函数可以像变量一样传递给其他函数作为参数（某一个函数有参数，这个参数是一个变量）\r\n    - 函数可以作为其他函数的返回值\r\n    - 函数可以用于给变量赋值可以存储在数据结构中\r\n  - 高阶函数（Higher-Order Functions）\r\n    - 函数作为函数的参数\r\n    - 函数作为函数的返回值\r\n  - 函数式编程（Functional programming）\r\n    - 函数式编程是和面向对象、面向过程同一级别的编程方法或编程模式\r\n    - 函数是一等公民是函数式编程的必要条件，经常用在高阶函数中\r\n    - 后面我们会有单独的文章介绍函数式编程\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38209595-770e96ea-36e7-11e8-8af1-4bb3f6d9940a.png)\r\n\r\n我们可以看到 any 函数的定义，predicate 参数是一个函数，这个函数的返回值是一个 Boolean 类型的值：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38209863-3508b194-36e8-11e8-8f49-2dd4ab2e915f.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38210322-b00910ae-36e9-11e8-876b-04f95b40a509.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38210328-b4d9b3fe-36e9-11e8-9ae0-542c1f5fa689.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38210330-b68dbdc6-36e9-11e8-914b-9de940557819.png)\r\n\r\n简化到最后，就很简单了。有没有觉得函数式编程特别神奇呢？\r\n\r\n### Task 6：Strings\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38261883-27ff9150-379e-11e8-812a-f6c92364dfbc.png)\r\n\r\nKotlin 字符串可以像 Java 一样，也可以用三个双引号声明，三个双引号声明的字符串其中可以包含多行。字符串模板可以很方便在字符串中使用变量，则这个题的答案就是：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38262362-95ce611a-379f-11e8-9138-fd3ccc207be6.png)\r\n\r\n这里我们用了 `trimIndent()` 方法对缩进进行格式化，还可以使用 `trimMargin()`，如下图，其中的竖线 `|` 是trimMaring 默认格式化特殊字符：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38262484-e7643054-379f-11e8-901e-23e48d4c3153.png)\r\n\r\n### Task 7：Data classes\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38262607-4e1532bc-37a0-11e8-9f21-9ef25e3b1eef.png)\r\n\r\nDate Class 是什么东西？我们先来了解 Kotlin 中集中数据结构：\r\n\r\n  - Class\r\n    - 与 Java 类类似，是一种数据结构\r\n    - Kotlin 中的 Class 继承自 Any，而不是 Object\r\n    - 用关键字 constructor 声明构造函数，够着函数可以有默认值\r\n    - 构造函数分为主构造函数和二级构造函数，主构造函数跟在类名后由关键字 constructor 和参数表共同构成，二级构造函数在类中，用 constructor 和参数列表构成，注意如果有主构造函数，二级函数必须调用主构造函数。如 `constructor(name: String, parent: Person) : this(name)`。\r\n    - 主构造函数无法执行代码，如果需要执行一些代码时，可以用 `init{}` 在类中执行，可以声明多个 `init{}`，执行顺序与声明顺序一致。\r\n    - 默认类不可以被集成，方法不可以被重写，如果希望类被继承或方法可以被重写，可以在类或方法前加 `open` 关键字。\r\n    - 子类在重写父类方法时，需要在方法前加 `override` 关键字\r\n    - `super` 关键字调用父类方法\r\n    - `abstract` 关键字定义抽象类，`interface` 关键字定义接口。\r\n    - 普通情况下，类没有静态方法，如果需要静态发发或所有静态属性，需要用伴随对象 `companion object`，相当于独立于类开辟了一块空间，所有对象共有。\r\n  - Properties and Fields\r\n    - val 修改不可更改的属性\r\n    - var 修饰可以更改的属性\r\n    - lateinit 修饰延迟加载的属性，在需要用的时候才初始化。\r\n  - Data Class\r\n    - 有些时候，创建类就是为了让其可以有几个属性，Java 中的 Bean 对象，而在 Kotlin 中，将这种数据结构单独定义为 `data class`\r\n    - 其中会自动创建一些方法，如 `copy()`，`equals()` 等\r\n    - 我们在后面会有主题讲解 `data class`\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38264093-91af2ad8-37a4-11e8-83d2-877d25496ff7.png)\r\n\r\n用 `data class` 可以很简单的定义数据结构，并且其中自动包含了 get/set 方法，易读且方便。\r\n\r\n### Task 8：Nullable type\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38264226-f12c544a-37a4-11e8-8e3a-b19312f6e8c3.png)\r\n\r\nJava 中经常需要判空，如果不为空，获取其中某些属性值等，写起来不优雅，且不安全，Kotlin 中采用了更简单的方式。\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38264563-fa13644e-37a5-11e8-9a2c-192443080f2a.png)\r\n\r\n注意，这并不意味着 Kotlin 中就完全不需要关心变量为空引起的错误，我们后面会具体详细说明一些 Java 代码转成 Kotlin 或直接 写 Kotlin 代码引起的一些错误，是一个需要填的坑。\r\n\r\n### Task 9：Smart casts\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38264665-4b3466a2-37a6-11e8-8367-69fb4fda9944.png)\r\n\r\n自动类型转换是一个很聪明的特性。Kotlin 中没有 switch-case，代替它的是 when，这里的例子是判断 expr 具体是哪一种类型，这里可以展现出 Kotlin 强大的是在判断一个对象是哪一种类型后，后面这个变量直接转换成该类型，而不像 Java 中需要强转。\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38264833-ce0526a2-37a6-11e8-9f34-54c051a8db90.png)\r\n\r\n### Task 10：Extension functions\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38265131-891c07ee-37a7-11e8-9e9b-fa83a01396d4.png)\r\n\r\n扩展函数。有些时候，某些类功能不够强大，你希望扩展这个类，而你又不能修改该类的源代码，如果是 Java，你可能需要继承自功能不够强大的类，添加新方法，然后使用新的类，这比较麻烦，也可能会因为需求的变更，这个类越来越不好维护。Kotlin 的方式是在不修改原来的类的代码的情况下，扩展方法出新的方法，使用起来就像是在原来的类中添加了新的方法。\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38265370-420e7b7e-37a8-11e8-9a2e-0c1097c169d2.png)\r\n\r\n在没有修改 Int 和 Pair 对象的情况下，他们都有了转成有理数的方法了。\r\n\r\n### Task 11：Object expressions\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38265505-b22e4998-37a8-11e8-938b-8c9a3421e424.png)\r\n\r\n对象表达式。Kotlin 的对象表达式与 Java 中的匿名内部类差不多。有些情况只用一次的对象，没必要写成一个类。\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38265795-791a9da4-37a9-11e8-94db-17c4da25859e.png)\r\n\r\n简化代码改为 Lambda 表达式：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38265760-6113d374-37a9-11e8-8ebf-25d829797d7d.png)\r\n\r\n再简化代码，使用 Kotlin stdlib：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38265762-61defc66-37a9-11e8-8e19-262e7b25c1c4.png)\r\n\r\n了解越多 Kotlin stdlib 中的方法，写代码越快，效率越高。\r\n\r\n### Task 12：Extension functions on collections\r\n\r\nKotlin 在集合类中做了大量的优化，提供了大量的有用的方法，这里排序可以直接调用。\r\n\r\n```\r\n/**\r\n * Returns a list of all elements sorted descending according to their natural sort order.\r\n */\r\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\r\n    return sortedWith(reverseOrder())\r\n}\r\n```\r\n\r\nKotlin 提供了自然序的升序降序排序方法：`sortedDescending`\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38266361-191bb59e-37ab-11e8-9b3a-894e52077e24.png)\r\n\r\n### Task 13：Comparison\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38266502-6b5299ae-37ab-11e8-8d6e-c928b67fec7f.png)\r\n\r\n我们定义了一个类 MyDate，我们现在直接用 `<` 对这个类的对象比较大小。我们需要对这个对象定义比较大小操作符，则只需重写 compareTo 方法就可以了。\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38266891-73b5a9d2-37ac-11e8-8fbe-ccf88e1a1fb2.png)\r\n\r\n### Task 14：Task In range\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38267005-ba745bac-37ac-11e8-90ed-8fd5f1b6172f.png)\r\n\r\n有了上面的经验，这里只需了解 in 操作符是调用的 contains 方法就可以了：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38267150-30fc8b78-37ad-11e8-8621-c940f75093ef.png)\r\n\r\n简写成（其中 `..` 就是执行 `rangeTo` 方法）：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38267154-3168ca9a-37ad-11e8-99c8-dc5f3ed0dede.png)\r\n\r\n### Task 15：Range to\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38290036-d9de90de-380b-11e8-8123-2b939420fe45.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38290082-1075fc86-380c-11e8-89df-c8b41ad9b006.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38290273-099f5154-380d-11e8-8743-511074c45d16.png)\r\n\r\n我们在上一个任务中，有编译器自动提示使用了 `in - ..` 操作符，我们点进去看看，发现其实就是执行了 `rangeTo` 方法，这一个任务中，我们就需要实现 `rangeTo` 方法就可以，`rangeTo` 方法返回值是 `ClosedRange`，而 `ClosedRange` 需要对象实现比较大小 `compareTo` 方法，恰好我们上一节中已经在 MyData 中实现了 compareTo，恰好 DateRange 实现了 ClosedRange，因此我们可以直接使用，结果如下：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38289989-a37a73f0-380b-11e8-8281-6004ed80cec4.png)\r\n\r\n这个任务比较复杂，但是逻辑是很清晰的。\r\n\r\n### Task 16：For loop\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38290472-ed182d3e-380d-11e8-89ad-170574cb4f4b.png)\r\n\r\nFor 循环需要迭代器，DateRange 需要实现 Iterable，则问题就简单了：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38469818-59c374b6-3b8d-11e8-845d-2cf467ace0cf.png)\r\n\r\n当然，可以优化代码：\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38469851-cc465de6-3b8d-11e8-8ef6-9b482d23c6e4.png)\r\n\r\nFor 循环就是迭代器的遍历。\r\n\r\n### Task 17：Operators overloading\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38469863-fa6632b4-3b8d-11e8-8953-46822a7e4c77.png)\r\n\r\n`+` 操作符，其实就是实现 `plus` 方法。`*` 操作符就是实现 `times` 方法\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38470065-575ea4a4-3b90-11e8-8ff2-685514a3d3d0.png)\r\n\r\n### Task 18：Destructuring declarations\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38470103-db98986a-3b90-11e8-9c00-6f723659a5ea.png)\r\n\r\n可以将对象属性值赋值给其他对象，要求这个对象必须由 data 修饰。\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38470104-dc3c3c5e-3b90-11e8-9b4b-ae80520cc56b.png)\r\n\r\n### Task 19：Invoke\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38470180-9816af2c-3b91-11e8-8d10-5bd5fa68b916.png)\r\n\r\n![图片](https://user-images.githubusercontent.com/7275046/38470181-98dc25a4-3b91-11e8-8e71-1fc878e446bc.png)\r\n\r\n# 小结\r\n\r\n本文主要了解了一些 Kotlin 的具体实现方法，对真正写 Kotlin 程序极有好处。\r\n\r\n到这里，我们完成了一半的任务，为避免篇幅过长，下面的任务我们在下一篇文章中继续讨论。\r\n\r\n---\r\n如果有一天你觉得过的舒服了，你就要小心了！欢迎关注我的公众号：我是任玉琢\r\n\r\n![qrcode_for_gh_45402a07f7d9_258](https://user-images.githubusercontent.com/7275046/37878351-56acaf0c-309a-11e8-8d8d-10255972a59f.jpg)\r\n"},{"number":24,"title":"【用 Kotlin 写 Android】有这个必要吗？","created_at":"2018-03-25 18:07:10","body":"### 前言\r\n\r\n  Kotlin 被 Android 选为官方支持并推荐的语言满一年了，这一年中可以看见的是 Google 正在大力推广 Kotlin，并且相关的 Kotlin 支持库也频繁更新，可以预见的是在未来一段时间内，Kotlin 会被越来越多的提及，并且也会被越来越多的采用，那作为一个互联网从业者——一日不学习就会被淘汰的的行业的从业者，那么是否 Android 开发就应该立刻去采用 Kotlin 开发呢？答案是不一定，要视情况而定，但可以确定的是，现在是要深入去研究 Kotlin 的时间了，至于原因，下面会仔细分析。本系列文章，就是深入分析 Kotlin 的教程系列，欢迎在后台留言交流。下面我们将开始我们的学习之旅，希望你不会中途放弃！\r\n\r\n# 【用 Kotlin 写 Android】有这个必要吗？\r\n\r\n**答案是不一定。**\r\n\r\n为什么呢？我们先回答一个问题：我们现在的现有的项目是否都应该改用 Kotlin 去写？新项目和老项目选择起来有区别吗？我的答案是：\r\n\r\n  1. 老项目不是必要的；\r\n  2. 新项目如果有大量代码复用以前的代码而不是以依赖的方式引入的话，可以引入 Kotlin，但是不建议这样干；\r\n  3. 而对于新项目，且对于可预见的一段时间内，维护这个项目的人都能比较好的采用 Kotlin 来维护的话，这个项目就建议采用 Kotlin 来写。\r\n\r\n为什么会有这样的结论？这个听我慢慢解释。\r\n\r\n首先，如果这个项目是一个比较久一点的项目，以前采用了的是原生 Java 来写的话，经过了这个长时间的维护演变我相信很大的可能这个项目经过很多个人修改，业务逻辑也很复杂了，很可能维护起来都没有那么简单了，理清里面的逻辑都没有那么简单了，更别说将其转换成 Kotlin 来写了，如果用 Android Studio 中自带的转换工具去转换，很大的可能是转换后，有几十几百的文件需要修改，空指针的判定都需要重新检查一遍，否则编译都很难通过，何况由于 Java 和 Kotlin 语法糖不一致，和可能在转换后同等替换的代码都可能无法按预期执行，常见的重载前后都有可能调用不同的方法(这个在后面的文章会有解析)。更不要说其中最难理解的业务逻辑了，如果真的转换了，那真的是噩梦一场，会非常痛苦！对于含有复制业务逻辑的代码，如果不想一周不眠不休的加班，那就不要这样干。同时在多人维护的项目中，贸然转换，很难去保证以前 Java 代码写的很好的人 Kotlin 也能写的很好，何况有些人还不打算转用 Kotlin，谁能保证转了之后不会引发血案呢？\r\n\r\n其次是新项目复用很多老项目的代码，要不要引入 Kotlin？如果你问这样的问题，我猜测你所在的公司是一些规模不是很大的公司，同时开发多个 APP，而你又恰好是这些开发中比较有影响力或者说是中坚力量的那一个人，你会考虑这个问题，如果考虑实际情况，其实有可能是可以引入 Kotlin 的，但是还是上面讨论的问题，引入那些老代码，不可预知会与现在的 Kotlin 代码之间会出现什么问题？上面说的问题都还是存在的，不过因为这是一个新项目，因此老代码的引入是一步一步进行的，新写的代码采用 Kotlin，老代码在引入的过程中，是可以逐步转换成 Kotlin 的，或者即使不转换成 Kotlin，两种代码共存，风险也是可控的，这个过程中，会有一定阵痛期，可以根据实际情况，看团队素质进行决定，如果没有特别的理由转换成 Kotlin，采用原来的代码是一个不错的选择，也是我认为最好的选择，毕竟，这样的话，招人也会好招一点。\r\n\r\n最后是一个全新或接近全新的项目，要不要用 Kotlin，我的答案是如果可能，尽量用 Kotlin。为什么呀？我觉得有几点原因吧：\r\n\r\n  1. 不管你喜不喜欢，未来很大可能是 Kotlin 代替 Java，**Google 已经决定要这么干了**，Android 还是他的亲儿子，那以后 Android 对 Kotlin 的支持会越来越好，你不那么干，只会自讨苦吃，如果没有足够的实力，不要与他作对！\r\n  2. Kotlin 确实有很多优秀的特性，没有 Java 语言的历史包袱，包含了很多优秀的编程思想，尤其是 Kotlin 的 **函数式编程** 的思想，确实让开发更开心了很多。\r\n  3. 减少了一些本来就没有那么多必要的模板代码，空指针判断，**提高开发效率**，这也是最重要的一点。\r\n  4. 很多语法糖更接近自然语言。记得我学习编程的时候，最开始学习伪代码，然后脱离伪代码去写 Java，Kotlin 在很多方面比 Java 更接近伪代码，更接近人类自然语言，这是巨大的进步。\r\n  5. 宇宙第一 IDE 公司 IDEA 开发的 Kotlin，未来写 Kotlin 代码会比 Java 更爽。\r\n  6. **Jake Wharton 加入 Google Kotlin 团队**。这也许不应该算是一个理由，但不得不承认那些 Android 领域最聪明的大脑都在为 Kotlin 发展贡献着力量，就算是为了学习，为了接近他们，我们也没有理由不去学习 Kotlin。\r\n\r\n说了这么多，是时候要回归主题了，用 Kotlin 写 Android 有没有必要？答案是不一定，需要具体去根据项目情况去决定。但可以确定的是学习 Kotlin 是有必要的，想继续从事 Android 开发，Kotlin 必须要学。\r\n\r\nKotlin 要学习到什么程度呢？Kotlin 官网上说，如果你以前用 Java 开发 Android，你可以很容易的使用 Kotlin 开发，我觉得这说的没问题。但是如果说想用好 Kotlin，那这个问题就没那么简单了，他是思维方式的变化，Kotlin 建议采用函数式编程，这与 Java 的面相对象编程有很大的不同。我看过的最经典例子是：第一次学习 Java 就想刚开始学习开车，感觉别人很容易，但真正自己去开车的时候就发现没有那么简单了，你需要一点一点的补充自己的知识，从刚开始只可以在村子里开一开，到拿到驾照可以去任何你想开车去的地方，这经历了刻苦的练习。Java 版本的升级，就相当于有一天你的车开的太久了，你买了一辆新车，你可能一开始不是很熟悉，但是当你坐上车，简单检查了一下转向灯，喇叭在什么位置如何去使用后，你就可以直接开走了，因为很可能在开始的时候你不需要那些新知识就可以把车开回家，播放音乐的功能以后你可以慢慢去了解。但是如果你使用 Kotlin 可就不是换车那么简单了，而是说你现在要去开飞机了！啊，飞机，这就麻烦了，你都不知道飞机的倒挡在哪里，怎么办呀？但是当你理解了飞机在天上不可能倒着飞的时候，你就知道倒挡其实对飞机飞行是没有帮助的。这就是两种思维方式的变化。这个例子来自于：[So You Want to be a Functional Programmer (Part 1)](https://goo.gl/57JgyE)，飞机可以在陆地上其实是可以倒着走的锅我不背。\r\n\r\n说了这么多，最后翻译一下 Kotlin 官网上说的 Kotlin 相比较 Java 开发的优势吧：\r\n\r\n  - 兼容性好：Kotlin 由 Java 6 编译，老手机上也可以很好的运行。\r\n  - 性能好：Kotlin 和 Java 都是运行在 JVM 上，都会被编译成字节码，因此有同样好的运行速度。同时由于支持内联函数、lambdas，有些时候运行起来比用 Java 写的代码更快。\r\n  - 互操作性：与 Java 100% 兼容，可以互相调用，以前的库可以使用。（这种话不能信，有些情况有些坑，需要程序猿保证，本系列之后的文章会介绍常见的一些坑）\r\n  - 体积：很小的运行兼容库，可以使用混淆 ProGuard，在应用中只增加了几百个函数，少于 100k 的大小（这是官方数据，代表真实情况，毕竟你可能还会引入一些 Kotlin 相关的其他优秀的库，比如 Anko）\r\n  - 编译时间：编译的时候会有额外的清理时间，不过增量编译往往和 Java 差不多甚至好于 Java\r\n  - 学习曲线：没什么难度，有相关插件，几行代码可以搞定（Android Studio 默认创建项目时可以直接选择支持 Kotlin，但是如果想用好 Kotlin，还是需要仔细学习的，所有语言都一样，想用好 Java 也没那么容易）\r\n\r\n## 总结\r\n\r\n前面啰嗦的话说完了，总结起来就是不管你用不用，是时候该开始学习 Kotlin 了，**【用 Kotlin 写 Android】**系列也正式开启。PS：我也需要更多的准备才能写好这个系列，一起加油！！\r\n\r\n**Are You Ready? Go!**\r\n\r\n参考链接：\r\n- 函数编程开发者：https://goo.gl/57JgyE\r\n---\r\n如果有一天你觉得过的舒服了，你就要小心了！欢迎关注我的公众号：我是任玉琢\r\n![qrcode_for_gh_45402a07f7d9_258](https://user-images.githubusercontent.com/7275046/37878351-56acaf0c-309a-11e8-8d8d-10255972a59f.jpg)\r\n"},{"number":22,"title":"加班的思考","created_at":"2017-12-07 02:44:36","body":"## 前言\r\n\r\n这周要发版本，没问题，由于工作量太大，加上自己效率不足以轻松完成此工作，那就只能加班了，当然，不是我自己，是我们的小 Boss、Team 成员和两个测试。一直弄到了凌晨三点半，有点累。明天是周六，或者说今天是周六，一会就需要去找我的女神去了，这一天见到她肯定可开心，那就回家睡两个小时然后去吧。可是问题是到家里开不开门了，被室友反锁了，这防盗意识还是很不错的，不过我怎么进去呀！门铃也没什么反应。席地而坐，用电脑连 WiFi 写点这周工作的一点关于程序员的一点思考吧。\r\n\r\n## 正文\r\n\r\n### 怎么去考虑将要做的功能？\r\n\r\n什么意思？根据用户使用习惯、大量用户数据的使用习惯分析，加上产品经理对产品的定义，会出来用户需求。这个需求指的是用户痛点，该应用就应该去思考怎么去满足用户的这些痛点，交给 UI 进行设计和开发进行程序实现。其实这个时候就会出现一个问题。\r\n\r\n> **这个需求是不是真的满足了用户的需求，这个需求会不会变，这个需求以后会怎么进行版本迭代，会怎么改！**\r\n\r\n哇，这个问题好难！我其实不是很关心这个需求对用户的帮助，而是更关心以后会怎么变，现在写的代码如何去适应这种变化。老实说，其实现在写代码之前，比较少的去考虑这些，也没有特别多的设计，这也导致了一个问题，日后改起来真的会让人抓狂，根本不清楚自己曾经写过什么，当时的一些做法也完全弄不懂是为什么要这么干，程序能大致按照预期去执行已经很不错了，更多的情况是不能很好的执行。\r\n\r\n这是问题呀！我大学学的专业是：软件工程。软件工程和计算机科学与技术最大的不同也体现在软件工程专业把很多的关注点和精力放在了如何让项目正常推进，如何去保证项目稳定安全的发布出去，如何保证不会延期，如何保证代码质量。这不是靠程序猿的自我修养，这是要去思考要去想办法达到的目标的。这里会有好多的问题。之所以说到这个问题，是因为现在的代码已经完全乱掉了，维护起来已经比较吃力了，各种奇奇怪怪的逻辑已经让程序变得复杂，不同的代码规范已经让程序没有人能完全适应，对于程序中的很多耦合关系已经成为互相关联的关系网，动其中任何一个角都有可能打破这个脆弱的平衡。用一句话形容：\r\n\r\n> **Bug 与事件起飞，状态影响共长天一色**\r\n\r\n这样的代码会导致有很多问题被隐藏其中，当某一天从一个点爆发出来，就可能如洪水泛滥一发不可收拾！当然了，比较幸运的一点是我们现在需要做的仅仅是一个应用，不是一个庞大的系统，并且在一个可预见的未来，这个项目规模并不会爆发式增长，并且写代码的人都还在！还可以维持这个状态，还可以让这种状态继续下去，维护这个项目的程序猿需要有更多的耐心和细心，当处理一些问题时，注意尽量找出各方面的关联吧！\r\n\r\n如果有一天能重构代码，真的有那么简单吗？未必，保持现在的这样一个状态，维持到这个项目结束可能更是一个好的选择。\r\n\r\n话说回来，为什么这个项目中用到了那么多的事件（EventBus），我们都知道这个东西很方便，确实呀，的确好用。我们也知道这个东西会随着时间的发展逐渐造成项目的难以维护，没办法，有好必有弊嘛，问题是我们没有很好的在这些好处和弊端中进行一个很好的折中，导致了很多的滥用。甚至有的时候还有一种既然这个地方都已经这么做了，那干脆就这么干吧这样的一种心态。这个问题需要再考虑考虑吧。\r\n\r\n最后想写一点的就是在开始写代码的时候，仔细去考虑考虑，也许用五分钟考虑好了之后，这个问题就会变得豁然开朗，不禁大叫：“我靠，代码还可以这么写，太漂亮了！”\r\n\r\n## 最后\r\n\r\n希望这个项目能好起来，有时间或做到什么地方就逐渐想办法让代码变得更好吧！\r\n\r\n20170826 早"},{"number":9,"title":"WebRTC 学习笔记","created_at":"2016-11-24 07:16:00","body":"## 前言\r\n\r\n本想用这篇文章在[Coding](https://coding.net/)上挣两个码币，可是失败了，好了，那就写在这里，错误之处欢迎指出，在下不胜感激。\r\n## 正文\r\n\r\n[WebRTC](https://webrtc.org/) 的全称为 Web Real-Time Communication，是一个由 Google 主导的通信协议和编程接口。Web 浏览器可以从计算机硬件获取视频或音频信息，也可以通过从其他用户浏览器获取实时数据，即可以实现视频或音频的通信。这项技术是 2010 年 Google 以 6820 万美元收购了 Global IP Solutions 公司，2011 年却将其开源了（也只有 Google 能干出这事），2013 年在 Google IO 大会上推广。由于 Google 的积极推动和标准的制定，已经得到了业界的支持，称为新一代视频通话的标准。\r\n## 平台通用性\r\n\r\nWebRTC 在不同浏览器上（包括 Chrome，Firfox，Opera 和 Microsoft Edge 等），不同的平台上（PC，Android，iOS 和 TV）都有统一的标准。借用并改编 [Sam Dutton](https://goo.gl/VczO0M) 的一句话：想象一下，在你的手机、电视和电脑都可以相互通信，想象一下很容易的你就可以与他人进行 P2P 的音视频的通信，多么美好，这都是 WebRTC 干的好事。\r\n\r\n确实是个好事，在浏览器上，点击输入一个网址，点击同意网站使用计算机话筒和摄像头，然后就可以与别人进行语音和视频通信了，不需要安装任何软件，也无需任何插件，因为在浏览器中已经内置了 WebRTC 了。\r\n\r\n同样，在移动端 Android 和 iOS 上，也有对应的 AppRTCMobile 可以安装并试用（在2016年9月28日前还叫 AppRTCDemo ）。与浏览器类似的操作，同样的方便。\r\n## 发展情况\r\n\r\n从 Google IO 大会上第一次提到 WebRTC 到现在，Google 的 [Duo](http://www.fiercewireless.com/wireless/google-takes-facetime-webrtc-based-duo)，[Apple](http://www.fiercewireless.com/tech/report-apple-quietly-reveals-support-for-webrtc)，微软的 [Edge](https://goo.gl/yM7RFG)，Skype，Facebook 等都对 WebRTC 进行了支持，并且有流行的趋势。WebRTC 到 2016 年已经过了五年，虽然不能说全部完善了，还有 bug，但是，已经可以使用，应该给予一定关注了。\r\n\r\n到这里，大致解决了 WebRTC 是什么和是否应该关注一下 WebRTC 的问题了。接下来就看看怎么使用吧，主要针对 Android 来进行讨论。\r\n## 尝试一下\r\n\r\n傲视天下的 [Linus Torvalds](https://en.wikipedia.org/wiki/Linus_Torvalds) 已经说过了，最好的学习程序的方法是“Reading The Fucking Source Code”，这里也一样，送源代码下载 [传送门](https://chromium.googlesource.com/external/webrtc/) ，当然，还要先看看 [官网](https://webrtc.org/) 。这里插播一条广告， WebRTC 代码更新的真的太快了，包括节假日每天都有多次新的提交，并且偶尔某次的提交会完全更改以前的设计，这一点真的让关注 WebRTC 的人吐血，也就是说很难说你已经下到了最新的代码，因为在说这句话的同时，可能又有新的提交了，这也让网上很多的资料过时的异常迅速，但是只能忍，人家是 Google。\r\n\r\n由于跟 Chrome 有关，下载代码如果仅仅下载了主分支的代码，其实是不好用的。需要下载 [depot_tools](http://dev.chromium.org/developers/how-tos/install-depot-tools) ，配置环境变量，然后用 `fetch` 和 `gclient` 命令下载，这一部分可以参考官网的 [Development](https://webrtc.org/native-code/development/)。官网也包含了编译和运行方法。当然，如果你只想了解一下，没必要下代码，下代码至少需要几个小时，你可以直接跳过这步， Google 的这些 [例子](https://github.com/webrtc/samples) 你可以试试。最后一点需要注意的就是WebRTC不可以本地运行，需要服务器，换一句话说，例子下载了直接用浏览器打开，是无法运行的，可以使用 [Chrome 的插件](https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb?utm_source=chrome-app-launcher-info-dialog)，相当于在服务器上运行。\r\n\r\n上面讨论的是浏览器部分，我承认我只是试了试官网 [Start](https://codelabs.developers.google.com/codelabs/webrtc-web/#0)，还算好玩，接下来重点讨论 Android 部分。\r\n\r\n关于 Android 部分，代码下载略有不同，我写过笔记，这里只送 [传送门](http://blog.renyuzhuo.cn/#/issues/2) ，就不赘述了。对于Android项目，同样送个 [传送门](https://github.com/RWebRTC/WebRTC-Android-Learn) ，这个代码下载后，用 [Android Studio](https://developer.android.com/studio/index.html) 打开，可以直接运行，也有编译好的 `apk` 文件，可能这样会有更多的人会真的试一试吧。服务器是官网 Demo 服务器，需要手机科学上网。\r\n## 技术分析——浅尝辄止\r\n\r\n下面讨论一下 WebRTC 的技术实现和几个关键的 API ，但我自知技术实在是太弱，只能浅尝辄止，抛砖引玉。\r\n### 先看几张图——全部图片来自网络\r\n\r\n![图片1](https://dn-coding-net-production-pp.qbox.me/16dd0919-6c85-4fa6-80d6-5755278b18a2.png)\r\n\r\n浏览器部分，封装了绝大部分功能，包括音视频编解码，网络通信、音视频数据捕捉和 P2P 相关等，用 C++ 向上层提供接口，W3C 制定标准，我们就可以使用浏览器的 API 了，网页就充当 APP 的角色。可能有人已经发现，这里有 P2P ，是的，看下面这张图。\r\n\r\n![图片2](https://dn-coding-net-production-pp.qbox.me/c85bc9ec-bf11-46ef-ad16-f1dd790fa7e4.png)\r\n\r\n两个浏览器进行通信，可以直接与对方建立 P2P 连接，交换媒体数据，中心网络服务器用来发送控制信息，包括断开连接，重连等，但是这时网络媒体数据并没有通过服务器，服务器压力也减轻了。但是又有问题了，建立P2P连接不成功了怎么办，长城，哦不，防火墙那么强大，哪有那么容易建立 P2P 连接的，看下图。\r\n\r\n![图片3](https://dn-coding-net-production-pp.qbox.me/2125c520-1f23-4d53-908d-d62907ed72a8.png)\r\n\r\n我们发现了，中间多了一个 Relay Server 。如果一切正常的情况下，通信的两端，可以穿透防火墙，建立 P2P 连接，如果没有穿透防火墙，那就只能通过中间 Relay Server 进行数据转发了。这样一来，信令的发送和多媒体数据的传输，都可以找到合适的方式进行传输。\r\n\r\n刚刚说了，与对方建立 P2P 连接，但是建立 P2P 连接都需要知道对方和自己的公网 IP 和端口，这个交给了 STUN Server 。看下面两张图片。\r\n\r\n![图片5](https://dn-coding-net-production-pp.qbox.me/1a5f9164-ef80-4c0c-a428-a7d14f67f924.png) \r\n\r\n[![图片4](https://dn-coding-net-production-pp.qbox.me/8ef509e1-0e50-417a-ae7e-0b22315ca7ba.png)](http://www.3cx.com/pbx/what-is-a-stun-server/)\r\n\r\n看了几张图，大致过程了解了，接下来是代码 API 时间。本文主要列举几个主要的类，水平有限，抛砖引玉。浏览器相关代码介绍看[这里](http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-first)。\r\n### [MediaStream](https://github.com/RWebRTC/WebRTC-Android-Learn/blob/master/RAppRTC-libs-src/libjingle_peerconnection_java-src/MediaStream.java)\r\n\r\n数据流。浏览器可以直接通过 getUserMedia 创建， Android 则通过工厂类创建。MediaStream 主要包含本地的和远程的两种，也就是要发送的数据和要接收的数据两种。同时，由于这是隐私敏感数据，浏览器和 Android 都会弹出提示窗口，请求用户确认权限。\r\n\r\n``` java\r\npublic class MediaStream {\r\n    public MediaStream(long nativeStream) {\r\n        this.nativeStream = nativeStream;\r\n    }\r\n\r\n    public boolean addTrack(AudioTrack track) {\r\n        // 调用本地C++方法\r\n        if(nativeAddAudioTrack(this.nativeStream, track.nativeTrack)) {\r\n            this.audioTracks.add(track);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean addTrack(VideoTrack track) {\r\n        // 调用本地C++方法\r\n        if(nativeAddVideoTrack(this.nativeStream, track.nativeTrack)) {\r\n            this.videoTracks.add(track);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n### [PeerConnection](https://github.com/RWebRTC/WebRTC-Android-Learn/blob/master/RAppRTC-libs-src/libjingle_peerconnection_java-src/PeerConnection.java) 和 [PeerConnectionFactory](https://github.com/RWebRTC/WebRTC-Android-Learn/blob/master/RAppRTC-libs-src/libjingle_peerconnection_java-src/PeerConnectionFactory.java)\r\n\r\n加载 JNI，创建连接，Android 中同时提供向连接中添加 VideoTrack 和 AudioTrack 方法，即向连接中添加数据流。这里应该提一下， WebRTC 对于数据是先将原数据 Capture 封装成 Source，在将 Source 封装成 Track ，再使用 MediaStream 的 addTrack 方法添加 Track，使用 PeerConnection 的 addStream 方法添加 mediaStream，而 PeerConnection 又是由 PeerConnectionFactory 创建的，因此，就是：\r\n\r\n``` java\r\n// 忽略方法参数\r\nPeerConnectionFactory factory = new PeerConnectionFactory();\r\nPeerConnection peerConnection = factory.createPeerConnection();\r\nmediaStream = factory.createLocalMediaStream();\r\nmediaStream.addTrack(createVideoTrack(videoCapturer));\r\npeerConnection.addStream(mediaStream);\r\n```\r\n\r\n同样看一下源代码，其中就包含了上述提到的方法。\r\n\r\n``` java\r\npublic class PeerConnectionFactory {\r\n\r\n    public PeerConnectionFactory(PeerConnectionFactory.Options options) {\r\n        this.nativeFactory = nativeCreatePeerConnectionFactory(options);\r\n        if(this.nativeFactory == 0L) {\r\n            throw new RuntimeException(\"Failed to initialize PeerConnectionFactory!\");\r\n        }\r\n    }\r\n\r\n    public PeerConnection createPeerConnection(RTCConfiguration rtcConfig, MediaConstraints constraints, Observer observer) {\r\n        long nativeObserver = nativeCreateObserver(observer);\r\n        if(nativeObserver == 0L) {\r\n            return null;\r\n        } else {\r\n            long nativePeerConnection = nativeCreatePeerConnection(this.nativeFactory, rtcConfig, constraints, nativeObserver);\r\n            return nativePeerConnection == 0L?null:new PeerConnection(nativePeerConnection, nativeObserver);\r\n        }\r\n    }\r\n\r\n    public MediaStream createLocalMediaStream(String label) {\r\n        return new MediaStream(nativeCreateLocalMediaStream(this.nativeFactory, label));\r\n    }\r\n\r\n    public VideoSource createVideoSource(VideoCapturer capturer) {\r\n        Context eglContext = this.localEglbase == null?null:this.localEglbase.getEglBaseContext();\r\n        long nativeAndroidVideoTrackSource = nativeCreateVideoSource(this.nativeFactory, eglContext, capturer.isScreencast());\r\n        AndroidVideoTrackSourceObserver capturerObserver = new AndroidVideoTrackSourceObserver(nativeAndroidVideoTrackSource);\r\n        nativeInitializeVideoCapturer(this.nativeFactory, capturer, nativeAndroidVideoTrackSource, capturerObserver);\r\n        return new VideoSource(nativeAndroidVideoTrackSource);\r\n    }\r\n\r\n    public VideoTrack createVideoTrack(String id, VideoSource source) {\r\n        return new VideoTrack(nativeCreateVideoTrack(this.nativeFactory, id, source.nativeSource));\r\n    }\r\n}\r\n```\r\n### [VideoCapturer](https://github.com/RWebRTC/WebRTC-Android-Learn/blob/master/RAppRTC-libs-src/libjingle_peerconnection_java-src/VideoCapturer.java)\r\n\r\n 如下图，为类的继承关系，可以使用 CameraCapture 简化相机操作。\r\n\r\n ![图片](https://dn-coding-net-production-pp.qbox.me/757cb989-e01f-4280-982a-f3edd119e1b2.jpg) \r\n\r\n当然，Android部分，还有比较重要的有一下几个类，但是相比对于了解 WebRTC 就不应该在这里介绍了：\r\n\r\n```\r\n网络相关：NetworkMonitor\r\n编解码相关：MediaCodecVideo\r\n数据格式相关：DataChannel\r\n```\r\n\r\n如果读者感兴趣自行阅读。\r\n## 后记\r\n\r\nWebRTC 还在发展，斗胆写了此文，抛砖引玉。错误之处，敬请指正，在下不胜感激。\r\n\r\n## 参考（以下链接可能需要科学上网）\r\n\r\n官网：https://webrtc.org/\r\n\r\nDemo：https://github.com/webrtc/samples\r\n\r\nIO Docs：https://goo.gl/p8fnYl\r\n\r\nSTUN：https://goo.gl/kvxWge\r\n\r\nDuo：https://goo.gl/mdy8Ca\r\n\r\nChromium：https://goo.gl/yU5W4g\r\n\r\nRWebRTC：https://goo.gl/aKweJt\r\n\r\nBlog：https://goo.gl/f9Vh2N\r\n\r\nNinja：https://goo.gl/RB4JVZ\r\n\r\nWebRTC on Android：https://goo.gl/ek5pi3\r\n"},{"number":5,"title":"[译] WebRTC 前世今生","created_at":"2016-11-24 07:11:03","body":"## 原文\r\n\r\n```\r\nhttp://www.html5rocks.com/en/tutorials/webrtc/basics/\r\n```\r\n## 翻译\r\n\r\n```\r\nWebRTC技术是激烈的开放的Web战争中一大突破。-Brendan Eich, inventor of JavaScript\r\n```\r\n### 无插件实时通信\r\n\r\n想象一下手机、TV和电脑都通过统一平台进行沟通。试想一下，很容易的在你的网站中添加视频聊天和P2P数据分享。这是WebRTC技术的愿景。\r\n\r\n想试一试吗？WebRTC在Chrome、Opera和Firefox中就可以使用。在apprtc.appspot.com中可以试一试这些例子：\r\n1. 在Chrome、Opera或Firefox中打开apprtc.appspot.com。\r\n2. 点击允许按钮让这个应用使用你的摄像头(Web应用程序)。\r\n3. 在一个新的标签页中打开底部的URL，最好在另外的电脑上打开。\r\n\r\n在这篇[文章](http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-simple)中有一个这个应用的例子。\r\n### 快速开始\r\n\r\n没有时间阅读这篇文章，或者只想尽快写代码？\r\n1. 看一看关于Google I/O大会上关于WebRTC的概述。（幻灯片在[这里](http://io13webrtc.appspot.com/)）\r\n2. 如果你没有用过getUserMedia，看一看项目中的这篇[文章](http://www.html5rocks.com/en/tutorials/getusermedia/intro/)，在[这里](http://www.simpl.info/getusermedia)可以看到示例代码。\r\n3. 了解一下RTCPeerConnection的API，点击[这里](http://www.html5rocks.com/en/tutorials/webrtc/basics/#simpleRTCPeerConnectionExample)和[这里](http://www.simpl.info/pc)，这个例子在一个简单的界面上实现了WebRTC。\r\n4. 了解更多关于WebRTC使用的服务器、防火墙和NAT穿透相关的内容。读[这里](https://apprtc.appspot.com/)看调试日志。\r\n5. 等不及了想试试WebRTC吗？这里有20多个[Demos](https://webrtc.github.io/samples)，试试这些javaScript的APIs。\r\n6. 使用你的机器有问题吗？[这里](https://test.webrtc.org/)可以找到测试用例。\r\n\r\n或者，直接跳到我们的[WebRTC codelab]()：一步一步的跟着指导，构建一个完整的视频聊天应用程序，包括一个简单的信令服务器。\r\n### WebRTC技术简史\r\n\r\n让人类通过网络进行音视频通信是网络最后的巨大挑战：实时通信(RTC)。实时通信就像网络上在文本框中输入文本一样自然，没有它，就限制了我们开发新的方式使人们互动交流起来。\r\n\r\n从历史上看，RTC变化很大很复杂，需要昂贵的音视频技术授权或者花费巨大代价去开发，RTC技术与现有的内容、数据和服务整合一直都很困难和耗时，在网络上尤其如此。\r\n\r\nGmail视频聊天在2008年开始流行，在2011年Google推出视频群聊，它使用GoogleTalk服务，就像Gmail一样。Google收购了GIPS，它是一个为RTC开发出许多组件的一个公司，例如编解码和回声消除技术。Google开源了GIPS开发的技术，与相关机构IETF和W3C制定行业标准。在2011年5月，爱立信实现第一个[WebRTC应用](https://labs.ericsson.com/developer-community/blog/beyond-html5-peer-peer-conversational-video)。\r\n\r\nWebRTC已经实现了对于实时通信，免插件音频数据传输的标准制定。需求是：\r\n- 许多网络服务已经使用了RTC，但是需要下载，本地应用或者是插件。包括Skype、Facebook、Google Hangouts。\r\n- 下载安装升级插件是复杂的，可能出错的，令人厌烦的。\r\n- 插件可能很难部署、调试、故障排除等——可能需要技术授权，复杂集成和昂贵的技术。说服人们去安装插件是很难的。\r\n\r\nWebRTC项目的指导原则是APIs应该是开源的，免费的，标准化的，浏览器内置的，比现有技术更高效的。\r\n### 我们在哪\r\n\r\nWebRTC应用在了各种App上，包括WhatsApp、Facebook Manager、appear.in和TokBox平台上。甚至在iOS浏览器上的实验WebRTC。WebRTC也被WebKitGTK+和QT内置使用。\r\n\r\n微软在Edge中增加了MediaCapture和Stream API。\r\n\r\nWebRTC实现了三个APIs：\r\n- [MeidaStream](http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-mediastream)(aka getUserMedia)\r\n- [RTCPeerConnection](http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcpeerconnection)\r\n- [RTCDataChannel](http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcdatachannel)\r\n\r\n**getUserMedia**在Chrome、Opera、FireFox和Edge中都实现了。看一看跨浏览器的[Demo](https://webrtc.github.io/samples/src/content/getusermedia/gum/)和亚马逊的[例子](http://webaudiodemos.appspot.com/)，使用getUserMedia作为音频的输入。\r\n\r\n**RTCPeerConnection**在Chrome、Opera和FireFox中实现。关于名字的解释：经过几次迭代，RTCPeerConnection被Chrome和Opera实现为webkitRTCPeerConnection，被FireFox实现为mozRTCPeerConnection。其他的名字都是过时的，当标准稳定时，前缀会被删除。在[Github](https://webrtc.github.io/samples/src/content/peerconnection/pc1/)上有超级简单的演示项目，构建在[apprtc.appspot.com](https://apprtc.appspot.com/)上。这个应用使用adapter.ja，一个JS库，来帮助WebRTC跨浏览器。\r\n\r\n**RTCDataChannel**被Chrome、Opera和FireFox支持。检出[Github](https://webrtc.github.io/samples/)上的Demo看看怎么使用。\r\n### 警告\r\n\r\n有些平台宣称支持WebRTC其实可能仅仅支持getUserMedia，而不支持其他的RTC组件。\r\n### 我的第一个WebRTC\r\n\r\nWebRTC需要做几件事：\r\n- 获取音视频流或其他数据流。\r\n- 获取网络信息例如IP地址和端口号，与其他客户端交换这些信息来进行连接，包括穿透防火墙。\r\n- 向signaling报告错误或启动会话关闭连接等。\r\n- 对于分辨率解码器等与其他客户端交换信息。\r\n- 传输音视频或其他数据信息。\r\n\r\n为了获得和传输数据，WebRTC实现了以下APIs：\r\n- MediaStream：从客户摄像头或麦克风获取数据流。\r\n- RTCPeerConnection：音视频通话，包括加密和带宽等的管理。\r\n- RTCDataChannel：P2P数据传输管道。\r\n\r\n（接下来详细讨论WebRTC的网络和信道）\r\n### MediaStream(aka getUserMedia)\r\n\r\nMediaStream API代表同步流媒体。例如一个来自摄像头和麦克风的流媒体输入已经同步了音视频。（不要混淆MediaStream和track标签，它们完全不同）。\r\n\r\n也许理解MediaStream的容易的方式是看它的表现：\r\n1. 在Chrome、Opera打开demo：\r\n\r\n```\r\nhttps://webrtc.github.io/samples/src/content/getusermedia/gum。\r\n```\r\n1. 打开调试器。\r\n2. 检查全局范围内的流变量。\r\n\r\n每个MediaStream有一个输入，navigator.getUserMedia()，也包括一个输出，输出到video标签或者是RTCPeerConnection。\r\n\r\ngetUserMedia()方法有三个参数：\r\n- 一个约束对象。\r\n- 成功回调，如果被调用，传递一个MediaStream。\r\n- 失败回调，如果被调用，传递一个错误对象。\r\n\r\n每个MediaStream有一个标签，例如\r\n\r\n```\r\n\"as'Xk7EuLhsuHKbnjLWkW4yYGNJJ8ONsgwHBvLQ\"\r\n```\r\n\r\n一个MediaStreamTracks数组被getAudioTracks()和getVideoTracks()返回。\r\n\r\n对于\r\n\r\n```\r\nhttps://webrtc.github.io/samples/src/content/getusermedia/gum/\r\n```\r\n\r\n例如stream.getAudioTracks()返回一个空的数组，因为没有音频，假设一个摄像头被连接上了，stream.getVideoTracks()返回一个MediaStreamTrack数组，代表这个摄像头的流。每个MediaStreamTrack有一个类型(音频或视频)，一个标签(有时就像FaceTime HD 照相机)，表示一个或多个音视频通道。在这个例子中，只有视频没有音频。很容易想象更多的例子：例如，一个聊天应用，前置想象头后置摄像头和麦克风，屏幕共享应用。\r\n\r\n在Chrome或Opera中，URL.createObjectURL()方法可以转换一个MediaStream到一个Blog URL，可以被设置作为视频的源。(在FireFox和Opera中，这个视频源可以通过stream本身创建)，自从M25版本，基于Chromium的浏览器(Chrome和Opera)允许通过getUserMedia获取的音频数据放置到audio和video标签上(但是注意到默认情况下将时静音状态)。\r\n\r\ngetUserMedia可以被作为[网页音频输入API](http://updates.html5rocks.com/2012/09/Live-Web-Audio-Input-Enabled)：\r\n\r\n```\r\nfunction gotStream(stream) {\r\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\r\n    var audioContext = new AudioContext();\r\n\r\n    // Create an AudioNode from the stream\r\n    var mediaStreamSource = audioContext.createMediaStreamSource(stream);\r\n\r\n    // Connect it to destination to hear yourself\r\n    // or any other node for processing!\r\n    mediaStreamSource.connect(audioContext.destination);\r\n}\r\n\r\nnavigator.getUserMedia({audio:true}, gotStream);\r\n```\r\n\r\n基于Chromium的应用或扩展也可以使用getUserMedia。在安装的时候仅一次添加audioCapture和/或videoCapture权限。此后用户不被询问关于摄像头和麦克风的权限。\r\n\r\n对于使用HTTPS的网页也是同样：对于getUserMedia只需呀授予一次权限。第一次时，在标签上信息栏上显示允许按钮。\r\n\r\nTODO 同时，Chrome将不鼓励getUserMedia()访问http，在2015年末，在M44版本，你可能在访问HTTP时看到一个警告。\r\n\r\n最终，不止照相机和麦克风，其他的任何数据流都可以放到MediaStream中。可以从硬盘中获取数据流，或者从任何其他传感器或其他输入获取数据。\r\n\r\n注意到getUserMedia()必须在服务器上使用，不可以在本地文件中使用。否则会报错。\r\n\r\ngetUserMedia()可以与其他javaScript类库一起使用：\r\n- Webcam Toy是一个照片类APP，使用WebGL来给照片添加奇怪的效果，可以被分享和保存到本地。\r\n- FaceKat是一个脸部跟踪的游戏，使用了headtrackr.js。\r\n- ASCII Camera使用了Ganvas API来生成ASCII照片。\r\n\r\n![ascii](https://raw.githubusercontent.com/RWebRTC/Blog/pictures/pictures/ascii.png)\r\n### 约束\r\n\r\n已经被Chrome、FireFox和Opera实现。这些可以被用来设置由getUserMedia()和RTCPeerConnection addStream()获取到的视频分辨率。这个目的是实现其他约束，例如面对模式（前后摄像头），帧速率，高度和宽度，使用的是applyconstraints()方法。\r\n\r\n在\r\n\r\n```\r\nhttps://webrtc.github.io/samples/src/content/getusermedia/resolution/\r\n```\r\n\r\n有一个例子。\r\n\r\n一个难以解决的问题：浏览器中，一个标签中getUserMedia设置的约束影响随后打开的标签页。设置不允许的值时给出了一个错误信息：\r\n\r\n```\r\nnavigator.getUserMedia error:\r\nNavigatorUserMediaError {code: 1, PERMISSION_DENIED: 1}\r\n```\r\n### 屏幕和标签捕获\r\n\r\nChrome应用也使得分享一个video标签在一个单一的浏览器标签中成为可能，或者整个桌面通过chrome.tabCapture和chrome.desktopCapture的APIs。在[这里](https://github.com/webrtc/samples/tree/master/src/content/getusermedia/desktopcapture)可以找到一个桌面capture的例子。对于截屏视频，代码和更多的信息查看[这里](http://updates.html5rocks.com/2012/12/Screensharing-with-WebRTC)。\r\n\r\nTODO 使用csreen capture作为一个MediaStream在chrome的源也是可能的，其中使用了chromeMediaSource约束，看这里[Demo](https://html5-demos.appspot.com/static/getusermedia/screenshare.html)，注意到屏幕抓取需要HTTPS并且应该用命令行标记，被WebRTC讨论解释。\r\n### Signaling：会话控制，网络和媒体信息\r\n\r\nWebRTC使用RTCPeerConnection在浏览器间传递数据流，但是也需要一个机器协调沟通发送控制i信息，这被称为signaling过程。Signaling方法和协议没有被WebRTC规定：signaling不是RTCPeerConnection的API的一部分。\r\n\r\n相反，WebRTC应用的开发者可以选择任何一种他们喜欢的消息协议，例如SIP或者是XMPP，或者任何全双工的通信通道。这个[apprtc.appspot.com](https://apprtc.appspot.com/)例子使用了XHR和Channel API作为这个Signaling。这个[Codelab](http://www.bitbucket.org/webrtc/codelab)使用了[Socket.io](http://socket.io/)，是一个[Node服务器](http://nodejs.org/)。\r\n\r\nSignaling被使用来交换三种信息：\r\n- 连接控制信息：初始化或者关闭连接报告错误。\r\n- 网络配置：对于外网，我们电脑的IP地址和端口？\r\n- 多媒体数据：使用什么编码解码器，浏览器可以处理什么信息？\r\n\r\n在进行P2P数据传输前，这些信息必须全部通过Signaling进行交换。\r\n\r\n例如，假设Alice想要与Bob通信。这是这个[例子](http://www.w3.org/TR/webrtc/#simple-example)，显示了这个过程中Signaling的信息。这个代码假设某些信号的存在，在createSignaling()方法中创建。也注意到有在Chrome和Opera上有前缀。\r\n\r\n```\r\nvar signalingChannel = createSignalingChannel();\r\nvar pc;\r\nvar configuration = ...;\r\n\r\n// run start(true) to initiate a call\r\nfunction start(isCaller) {\r\n    pc = new RTCPeerConnection(configuration);\r\n\r\n    // send any ice candidates to the other peer\r\n    pc.onicecandidate = function (evt) {\r\n        signalingChannel.send(JSON.stringify({ \"candidate\": evt.candidate }));\r\n    };\r\n\r\n    // once remote stream arrives, show it in the remote video element\r\n    pc.onaddstream = function (evt) {\r\n        remoteView.src = URL.createObjectURL(evt.stream);\r\n    };\r\n\r\n    // get the local stream, show it in the local video element and send it\r\n    navigator.getUserMedia({ \"audio\": true, \"video\": true }, function (stream) {\r\n        selfView.src = URL.createObjectURL(stream);\r\n        pc.addStream(stream);\r\n\r\n        if (isCaller)\r\n            pc.createOffer(gotDescription);\r\n        else\r\n            pc.createAnswer(pc.remoteDescription, gotDescription);\r\n\r\n        function gotDescription(desc) {\r\n            pc.setLocalDescription(desc);\r\n            signalingChannel.send(JSON.stringify({ \"sdp\": desc }));\r\n        }\r\n    });\r\n}\r\n\r\nsignalingChannel.onmessage = function (evt) {\r\n    if (!pc)\r\n        start(false);\r\n\r\n    var signal = JSON.parse(evt.data);\r\n    if (signal.sdp)\r\n        pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));\r\n    else\r\n        pc.addIceCandidate(new RTCIceCandidate(signal.candidate));\r\n};\r\n```\r\n\r\n首先，Alice和Bob交换网络信息。(\"finding candidates\"指的是使用[ICE 框架]()寻找网络端口)\r\n1. Alice使用onicecandidate句柄创建一个RTCPeerConnection。\r\n2. 当网络处理程序可用时，句柄运行。\r\n3. Alice向Bob发送序列化数据，通过无论那种方式：WebSocket或者其他方式。\r\n4. 当Bob从Alice获取到数据后，调用addIceCandidate添加远程节点描述中。\r\n\r\nWebRTC客户端(被称为peers，例如Alice和Bob)，也需要交换本地和远程音视频媒体信息，例如使用的协议和编码器。TODO Signaling来交换信息。\r\n1. Alice执行RTCPeerConnection的createOffer()方法，这通过RTCSessionDescription回调：Alice本地会话描述。\r\n2. 在这个回调中，Alice通过setLocationDescription()设置本地描述然后给Bob发送阶段描述通过他们的信道。注意到RTCPeerConnection直到setRemoteDescription被调用才会开始发送数据：在[这里](http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-03#section-4.2.4)被确定。\r\n3. Bob将Alice发送过来的消息进行设置作为远程信息的描述，通过setRemoteDescription()方法。\r\n4. Bob运行RTCPeerConnection的createAnswer()的方法，通过从Alice获取到的描述信息，本地会话可以适配她的。这个createAnswer()回调被一个RTCSessionDescription回调：Bob设置本地描述，发送给Alice。\r\n5. 当Alice获取到了Bob的本地描述，通过setRemoteDescription设置这个描述信息。\r\n6. 开始通信。\r\n\r\nRTCSessionDescription对象符合SDP，一个SDP类似于如下：\r\n\r\n```\r\nv=0\r\no=- 3883943731 1 IN IP4 127.0.0.1\r\ns=\r\nt=0 0\r\na=group:BUNDLE audio video\r\nm=audio 1 RTP/SAVPF 103 104 0 8 106 105 13 126\r\n\r\n// ...\r\n\r\na=ssrc:2223794119 label:H4fjnMzxy3dPIgQ7HxuCTLb4wLLLeRHnFxh810\r\n```\r\n\r\n网络和媒体信息的采集和交换可以同时进行，但这两个过程必须完成之前，音频和视频流之间的同龄人可以开始。\r\n\r\n网络信息的采集和交换可以同时进行，但是在发送音频和视频前都需要完成。。\r\n\r\n这个offer/andwer被叫做[JSEP](http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-00)(JavaScript Session Establishment Protocol)，在[这里]有一个很好的WebRTC实现的解释。\r\n\r\n![jsep](https://raw.githubusercontent.com/RWebRTC/Blog/pictures/pictures/jsep.png)\r\n\r\n一旦这个signaling完成了，数据可以直接的在端到端之间进行数据传输。如果失败了，通过中介服务器relay服务进行转发。Streaming是RTCPeerConnection的工作。\r\n### RTCPeerConnection\r\n\r\nRTCPeerConnection是WebRTC的一部分，它是稳定的有效率的端到端传输数据的句柄。\r\n\r\n下面是一个WebRTC的架构，显示了RTCPeerConnection的作用，正如你看到的，绿色部分和复杂！\r\n\r\n![webrtcArchitecture](https://raw.githubusercontent.com/RWebRTC/Blog/pictures/pictures/webrtcArchitecture.png)\r\n\r\n从JavaScript观点看，从图表中主要需要理解RTCPeerConnection向开发者屏蔽了底层复杂的东西。WebRTC使用的协议和解码器做了大量的工作才使得实时通信成为了可能，甚至在不可靠的网络的情况下：\r\n- 数据包丢包隐藏\r\n- 回声消除\r\n- 宽带自适应\r\n- 动态抖动缓冲\r\n- TODO 自动增益控制\r\n- 降噪\r\n- 图片清除\r\n\r\n在[W3C代码](http://www.html5rocks.com/en/tutorials/webrtc/basics/#simpleRTCPeerConnectionExample)从signaling观点显示了一个简化的例子。下面是两个使用WebRTC工作的两个应用，第一个是一个简单的RTCPeerConnection的例子；第二个时一个完全的可操作的视频客户端。\r\n### 没有服务器的RTCPeerConnection\r\n\r\n下面的代码是从[这里](https://webrtc.github.io/samples/src/content/peerconnection/pc1/)的Demo。包括网页上本地和远程的RTCPeerConnection。这个没有什么用，呼叫和被呼叫都在同一个网页上，但是确实使得理解RTCPeerConnection的API更清楚了，由于这个界面的RTCPeerConnection在没有Signaling时也可以直接交换信息。\r\n\r\n其他问题：TODO 看http://www.w3.org/TR/webrtc/#constraints获取更多信息。\r\n\r\n在这里例子中，pc1代表本地，pc2代表远程。\r\n#### 本地\r\n1. 创建一个新的RTCPeerConnection添加getUserMedia获取到的数据流。\r\n\r\n```\r\n// servers is an optional config file (see TURN and STUN discussion below)\r\npc1 = new webkitRTCPeerConnection(servers);\r\n// ...\r\npc1.addStream(localStream); \r\n```\r\n1. 创建一个offer并且设置本地的关于pc1的描述作为和远程pc2的描述。这在没有使用signaling的情况下可以直接完成，因为本地和远程都在一个界面上。\r\n\r\n```\r\npc1.createOffer(gotDescription1);\r\n//...\r\nfunction gotDescription1(desc){\r\n  pc1.setLocalDescription(desc);\r\n  trace(\"Offer from pc1 \\n\" + desc.sdp);\r\n  pc2.setRemoteDescription(desc);\r\n  pc2.createAnswer(gotDescription2);\r\n}\r\n```\r\n#### 远程\r\n\r\n创建pc2，添加pc1的流，在视频节点中显示：\r\n\r\n```\r\npc2 = new webkitRTCPeerConnection(servers);\r\npc2.onaddstream = gotRemoteStream;\r\n//...\r\nfunction gotRemoteStream(e){\r\n  vid2.src = URL.createObjectURL(e.stream);\r\n}\r\n```\r\n### RTCPeerConnection和服务器\r\n\r\n在真实的世界中，WebRTC需要服务器，但是时很简单的，下面的可能是现实的：\r\n- 通过用户名可以找到对方。\r\n- WebRTC客户端交换网络信息。\r\n- 端到端间交换媒体数据信息，例如分辨率和视频格式。\r\n- WebRTC客户端进行NAT和防火墙穿透。\r\n\r\n换一句话说，WebRTC需要四中服务类型的信息。\r\n- 用户发现和通信。\r\n- Signaling。\r\n- NAT/防火墙穿透。\r\n- 当端到端通信失败时，采用Relay服务通信。\r\n\r\nNAT穿透、端到端连接、用户发现和建立信令服务器超过了本文范畴。我想说的是，STUN协议和它的延伸ICE冰框架可以使用RTCPeerConnection处理NAT和其他网络变化。\r\n\r\nICE是一个连接端到端的框架，例如视频客户端。最初，ICE尝试直接连接，通过采用UDP实现更少延迟，在这个过程中，STUN服务有一个简单的任务：使一个在防火墙后面的设备找出公网IP和端口。Google有两个STUN服务器，其中一个在apprtc.appspot.com个例子中就使用了。\r\n\r\n![stun](https://raw.githubusercontent.com/RWebRTC/Blog/pictures/pictures/stun.png)\r\n\r\n如果UDP失败了，ICE尝试TCP：首先是HTTP，然后是HTTPS。如果直接连接失败了——特别的是因为企业的NAT和防火墙——ICE使用一个中继relay的TURN服务器。换句话说，ICE首先使用UDP的STUN服务器直接与对端连接，如果失败了，后退到TURN服务器。这表达了寻找网络和端口的过程。\r\n\r\n![dataPathways](https://raw.githubusercontent.com/RWebRTC/Blog/pictures/pictures/dataPathways.png)\r\n\r\nWebRTC工程师Jastin提供了关于ICE、STUN和TURN的更多的信息在2013年Google的IO大会上。([幻灯片](http://io13webrtc.appspot.com/#52)中有关于TURN和STUN的例子)\r\n### 一个简单的Chat客户端\r\n\r\n下面使用的信令服务器使用的是：https://apprtc.appspot.com。\r\n\r\n_如果你觉得这是有点令人困惑，你可能更喜欢我们的[WebRTC codelab](https://www.bitbucket.org/webrtc/codelab)。这篇指南介绍了如何一步步构建一个完整的视频聊天应用，包括使用Socket.io搭建一个简单的信令服务器。_\r\n\r\n[apprtc.appspot.com](https://apprtc.appspot.com/)是一个尝试WebRTC的好地方，这里使用了Signaling和NAT/firewall作为STUN服务器。这个应用使用[adapter.js](https://github.com/webrtc/adapter)处理不同的RTCPeerConnection和getUserMedia()的实现。\r\n\r\n这个代码是故意写的更长一点输出日志：查看控制台理解事件执行顺序。下面给出了一个详细的代码。\r\n### 接下来\r\n\r\n这个Demo以initialize()函数开始：\r\n\r\n```\r\nfunction initialize() {\r\n    console.log(\"Initializing; room=99688636.\");\r\n    card = document.getElementById(\"card\");\r\n    localVideo = document.getElementById(\"localVideo\");\r\n    miniVideo = document.getElementById(\"miniVideo\");\r\n    remoteVideo = document.getElementById(\"remoteVideo\");\r\n    resetStatus();\r\n    openChannel('AHRlWrqvgCpvbd9B-Gl5vZ2F1BlpwFv0xBUwRgLF/* ...*/');\r\n    doGetUserMedia();\r\n}\r\n```\r\n\r\n注意被openChannel()使用的room和token变量，是被Google APP自己提供的：看一下[这里](https://github.com/webrtc/apprtc/blob/master/src/web_app/html/index_template.html)，在这个库里看添加了什么值。\r\n\r\n这个代码初始化video变量将显示本地摄像头视频流和远程客户端视频流。resetStatus()简单的设置状态信息。\r\n\r\nopenChannel()函数设置WebRTC客户端之间的信息。\r\n\r\n```\r\nfunction openChannel(channelToken) {\r\n  console.log(\"Opening channel.\");\r\n  var channel = new goog.appengine.Channel(channelToken);\r\n  var handler = {\r\n    'onopen': onChannelOpened,\r\n    'onmessage': onChannelMessage,\r\n    'onerror': onChannelError,\r\n    'onclose': onChannelClosed\r\n  };\r\n  socket = channel.open(handler);\r\n}\r\n```\r\n\r\n对于Signaling，这个Demo是用的是[Channel API](http://code.google.com/appengine/docs/python/channel/overview.html)，这使得客户端间JavaScript没有轮询也可以通信。(WebRTC Signaling上面有详细介绍)。\r\n\r\n![apprtcArchitecture](https://raw.githubusercontent.com/RWebRTC/Blog/pictures/pictures/apprtcArchitecture.png)\r\n\r\n使用Channel API创建一个通道就像这样：\r\n1. Client生成一个独特的ID。\r\n2. Client A向APP Engine请求一个数据管道，发送这个ID。\r\n3. APP Engine通过Channel API，为这个ID和Token请求一个数据管道。\r\n4. APP将这个token返还给A。\r\n5. Client打开Socket连接监听这个服务器的管道。\r\n\r\n![channelEstablishing](https://raw.githubusercontent.com/RWebRTC/Blog/pictures/pictures/channelEstablishing.png)\r\n\r\n发送消息像这样：\r\n1. Client B发送一个POST请求给App Engine。\r\n2. App Engine通过一个请求给Channel。\r\n3. Channel携带着信息给Client A。\r\n4. Client A的接受消息回调被调用。\r\n\r\n![channelSending](https://raw.githubusercontent.com/RWebRTC/Blog/pictures/pictures/channelSending.png)\r\n"},{"number":4,"title":"[译] Android 上 WebRTC 介绍","created_at":"2016-11-24 07:09:55","body":"## 原文\r\n\r\n```\r\nhttps://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/\r\n```\r\n## 翻译\r\n\r\nWebRTC被称为开源网络发展的又一大里程碑，被看作为近些年对Web标准的最重要的创新。WebRTC允许开发者在网页应用中添加音视频，并且折不需要复杂的代码和昂贵的其他的基础设备。现在有Chrome、Firfox和Opera都已经支持了WebRTC，并将有更多的浏览器也将会支持，数十亿的设备已经支持了。\r\n\r\n然而，WebRTC也被称为城市神话(很多人都相信但实际上并不真实的故事)：WebRTC仅仅可以应用在浏览器上。事实上，WebRTC最重要的一个特征是它允许nativ和web app之间的互操作(跨平台)的。很少有人利用这一个特征优势。\r\n\r\n这篇Blog将介绍给你如何在你的Android应用中集成WebRTC，使用了WebRTC提供的本地库，提供者:[WebRTC Initiative](http://www.webrtc.org/)。我们不会强调通过signalling建立连接，而是强调Android和浏览器间的相似和差异。正如你将看到的，将包含一些连接到Web的APIs，如果你想看到更多的基本的关于WebRTC的介绍，请看：[Sam Dutton’s Getting started with WebRTC](http://www.html5rocks.com/en/tutorials/webrtc/basics/)。\r\n## 在你的项目中添加WebRTC的库\r\n\r\n```\r\n以下内容使用WebRTC库中的9127版本。\r\n```\r\n\r\n第一件事是添加WebRTC库到你的项目中。你可以自己[编译](http://www.webrtc.org/native-code/android)这个库，但是相信我，如果可以的话，避免自己编译。相反，使用[中央厂库](https://oss.sonatype.org/content/groups/public/io/pristine/)中已经编译好的文件。\r\n\r\n为了在你的项目中添加这个文件，需要这样写依赖：\r\n\r\n```\r\ncompile 'io.pristine:libjingle:9127@aar'\r\n```\r\n\r\n同步你的项目，你已经拥有了可以使用的库文件了！\r\n### 权限\r\n\r\n就像所有的Android一样，使用这个API你需要声明一些权限。WebRTC也不例外。根据你现在使用的或者是将来会使用的权限，例如音频和视频，你需要设置不同的权限。确保你只请求一次。一个可用的视频聊天应用的权限设置：\r\n\r\n```\r\n<uses-feature android:name=\"android.hardware.camera\" />\r\n<uses-feature android:name=\"android.hardware.camera.autofocus\" />\r\n<uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" />\r\n\r\n<uses-permission android:name=\"android.permission.CAMERA\" />\r\n<uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\r\n<uses-permission android:name=\"android.permission.INTERNET\" />\r\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\r\n<uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" />\r\n```\r\n## 灯光，相机……\r\n\r\n当在浏览器中使用WebRTC时，你可以使用一些很好用的API和文档可以参考：[navigator.getUserMedia](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getUserMedia)和[RTCPeerConnection](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)包含了大部分你需要的东西。结合video标签，本地和远程数据流一起使用。\r\n\r\n幸运的虽然他们有不同的名字，但是在Android这些API也不是很难。在Android中，我们讨论[VideoCapturerAndroid](https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#VideoCapturerAndroid\r\n\r\n[VideoRenderer](https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#VideoRenderer\r\n\r\n[MediaStream](https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#MediaStream\r\n\r\n[PeerConnection](https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#PeerConnection)\r\n\r\n[PeerConnectionFactory](https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#PeerConnectionFactory)。我们深入每一个探讨一下。\r\n\r\n然而，在你开始做任何这些事情前，需要创建PeerConnectionFactory，Android的WebRTC的核心。\r\n### PeerConnectionFactory\r\n\r\nWebRTC在Android上所有事情的核心。理解这个类并且知道它如何工作对彻底了解Android上的WebRTC至关重要。它也和你期望的有点不同，因此让我们讨论一下它吧，\r\n\r\n首先，初始化PeerConnectionFactory\r\n\r\n```\r\n// First, we initiate the PeerConnectionFactory with\r\n// our application context and some options.\r\nPeerConnectionFactory.initializeAndroidGlobals(\r\n    context,\r\n    initializeAudio,\r\n    initializeVideo,\r\n    videoCodecHwAcceleration,\r\n    renderEGLContext);\r\n```\r\n\r\n为了理解它如何工作，让我们看看每个参数：\r\n##### context\r\n\r\n简单的ApplicationContext，或者任何其他Context相关的上下文对象，跟你以前使用的一致。ing around.\r\n##### initializeAudio\r\n\r\nboolean值，初始化音频部分。\r\n##### initializeVideo\r\n\r\nboolean值，初始化视频部分。跳过这两个中的任何一个，允许你跳过询问API权限。例如DataChannel应用。\r\n##### videoCodecHwAcceleration\r\n\r\nboolean值，是否启用硬件加速。\r\n##### renderEGLContext\r\n\r\n可以提供这个值创建进程支持HW视频编码。可以被设置为null，这样的话就编码视频使用yuv420而不是texture帧。\r\n\r\ninitializeAndroidGlobals也将返回一个boolean值，正常初始化返回OK，有未初始化成功情况返回false。如果返回false时，是最好的练习的机会。查看源代码获取更多信息。\r\n\r\n假设一切正常，你可以使用PeerConnectionFactory的构造函数创建对象，与其他类一样。\r\n\r\n```\r\nPeerConnectionFactory peerConnectionFactory = new PeerConnectionFactory();\r\n```\r\n## 接下来获取媒体对象进行渲染\r\n\r\n一旦有了peerConnectionFactory实例，就应该从你的设备上获取音频和视频了，最终渲染到屏幕上。在网页上，你有getUserMedia和video可以用。在Android上也很类似，但是需要一点属相在Android上我们讨论：\r\nVideoCapturerAndroid，VideoSource，VideoTrack和VideoRenderer，都是以VideoCapturerAndroid开始。\r\n### VideoCapturerAndroid\r\n\r\nVideoCapturerAndroid类是一个相机的包装类，提供访问设备相机数据流的江边方法。允许你获取设备数量，获取前置后置摄像头\r\n\r\n```\r\n// Returns the number of camera devices\r\nVideoCapturerAndroid.getDeviceCount();\r\n\r\n// Returns the front face device name\r\nVideoCapturerAndroid.getNameOfFrontFacingDevice();\r\n// Returns the back facing device name\r\nVideoCapturerAndroid.getNameOfBackFacingDevice();\r\n\r\n// Creates a VideoCapturerAndroid instance for the device name\r\nVideoCapturerAndroid.create(name);\r\n```\r\n\r\n使用VideoCapturerAndroid类的实例，可以创建包含相机视频流的MediaStream，你可以给对方发送数据。在这之前，让我们看看我们怎样在应用中显示我们自己的视频。\r\n### VideoSource/VideoTrack\r\n\r\n为了从VideoCapture实例中获取有用的东西，获取PeerConnection需要的MediaStream，甚至仅仅使用，你都需要浏览一遍VideoSource和VideoTrack类的代码。\r\n\r\nVideoSource可以开始或停止你的设备。在无用停止抓取信息有助于电池使用寿命的延长。\r\n\r\nVideoTrack是一个添加VideoSource到MediaStream对象的一个包装。\r\n\r\n让我们看看他们一起使用时的代码。capturer是VideoCapturer的实例，videoConstraints是MediaConstraints的实例。\r\n\r\n```\r\n// First we create a VideoSource\r\nVideoSource videoSource =\r\n    peerConnectionFactory.createVideoSource(capturer, videoConstraints);\r\n\r\n// Once we have that, we can create our VideoTrack\r\n// Note that VIDEO_TRACK_ID can be any string that uniquely\r\n// identifies that video track in your application\r\nVideoTrack localVideoTrack =\r\n    peerConnectionFactory.createVideoTrack(VIDEO_TRACK_ID, videoSource);\r\n```\r\n### AudioSource/AudioTrack\r\n\r\n除了不需要AudioCapturer获取麦克风数据，AudioSource/AudioTrack和VideoSource/VideoTrack很类似。audioConstraints是MediaContraints的实例。\r\n\r\n```\r\n// First we create an AudioSource\r\nAudioSource audioSource =\r\n    peerConnectionFactory.createAudioSource(audioConstraints);\r\n\r\n// Once we have that, we can create our AudioTrack\r\n// Note that AUDIO_TRACK_ID can be any string that uniquely\r\n// identifies that audio track in your application\r\nAudioTrack localAudioTrack =\r\n    peerConnectionFactory.createAudioTrack(AUDIO_TRACK_ID, audioSource);\r\n```\r\n### VideoRenderer\r\n\r\n对于浏览器上的WebRTC，你可能很熟悉使用video显示通过getUserMeida获取到的MediaStream到的数据。然而在Android上，没有video标签。跟踪VideoRenderer，WebRTC库允许你实现你自己的方法。然而，也提供了一个很好的默认的方法[VideoRendererGui](https://chromium.googlesource.com/external/webrtc/+/master/talk/app/webrtc/java/android/org/webrtc/VideoRendererGui.java)，简单来说，VideoRendererGui是一个GLSurfaceView，在这之上，可以显示视频流。让我们看看如何设置，包括增加我们的renderer到VideoTrack上。\r\n\r\n```\r\n// To create our VideoRenderer, we can use the\r\n// included VideoRendererGui for simplicity\r\n// First we need to set the GLSurfaceView that it should render to\r\nGLSurfaceView videoView = (GLSurfaceView) findViewById(R.id.glview_call);\r\n\r\n// Then we set that view, and pass a Runnable\r\n// to run once the surface is ready\r\nVideoRendererGui.setView(videoView, runnable);\r\n\r\n// Now that VideoRendererGui is ready, we can get our VideoRenderer\r\nVideoRenderer renderer = VideoRendererGui.createGui(x, y, width, height);\r\n\r\n// And finally, with our VideoRenderer ready, we\r\n// can add our renderer to the VideoTrack.\r\nlocalVideoTrack.addRenderer(renderer);\r\n```\r\n\r\n一个需要注意的是createGui需要四个参数。可以使用一个GLSurfaceView渲染所有的视频。正如看到的，我们使用多个GLSurfaceViews，这意味着x/y将从0到合适的范围内变化。这是有意义的。\r\n### MediaConstraints\r\n\r\n这个MediaConstraints是WebRTC支持将视频和音频放入MediaStream的方式。看这个支持的[规范](https://w3c.github.io/mediacapture-main/#idl-def-MediaTrackSupportedConstraints)，大多数方法都需要MediaContraints的实例。\r\n\r\n```\r\nMediaConstraints audioConstraints = new MediaConstraints();\r\n```\r\n\r\n为了定制更多的限制，可以定义键值对，并将他们放到约束列表中。\r\n### MediaStream\r\n\r\n现在是时候讨论其他部分的功能了。在网页上，我们可能很熟悉MediaStream的概念了，getUserMedia直接返回一个MediaStream，你可以直接将其添加到RTCPeerConnection中发送给对端。对于Android也是一样，除了我们必须创建我们自己的MediaStream。让我们看看我们怎样可以添加VideoTrack和AudioTrack到一个恰当的MediaStream。\r\n\r\n```\r\n// We start out with an empty MediaStream object,\r\n// created with help from our PeerConnectionFactory\r\n// Note that LOCAL_MEDIA_STREAM_ID can be any string\r\nMediaStream mediaStream = peerConnectionFactory.createLocalMediaStream(LOCAL_MEDIA_STREAM_ID);\r\n\r\n// Now we can add our tracks.\r\nmediaStream.addTrack(localVideoTrack);\r\nmediaStream.addTrack(localAudioTrack);\r\n```\r\n## 你好，有人吗？\r\n\r\n我们在一个MediaStream实体中有了音视频流，除了显示在屏幕上，也应该传递给对方了。尽管本文不包括如何创建数据流管道的方法，我们将浏览一遍每个API的方法并解释与Web如何相关。AppRTC使用[autobahn](http://autobahn.ws/android/)使WebRTC连接到信令服务器。我建议你检出项目，详细了解一下Android如何设置信令服务器。\r\n### PeerConnection\r\n\r\n现在我们有了MediaStream，我们可以连接到对方了，幸运的是这一部分与Web很类似，因此如果你熟悉浏览器上的WebRTC，这部分和直接。在PeerConnectionFactory的帮助下创建一个PeerConnection是容易的。\r\n\r\n```\r\nPeerConnection peerConnection = peerConnectionFactory.createPeerConnection(\r\n    iceServers,\r\n    constraints,\r\n    observer);\r\n```\r\n\r\n参数如下：\r\n##### iceServers\r\n\r\n```\r\n向连接到外网这个是必要的，添加STUN和TURN服务器可以帮助你连接。\r\n```\r\n##### constraints\r\n\r\n```\r\n一个MediaConstrains的实例。应该包含offerToRecieveAudio和offerToRecieveVideo。\r\n```\r\n##### observer\r\n\r\n```\r\n一个PeerConnectionObserver的实例。\r\n```\r\n\r\n这个PeerConnection API与web很相似，包括像addStream、addIceCandidate、createOffer、createAnswer、getLocalDescription、setRemoteDescription一类的函数。通过[Getting started with WebRTC](http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcpeerconnection)查看两端怎样一起工作，或者看[AppRTC](https://chromium.googlesource.com/external/webrtc/+/master/talk)看WebRTC应用怎样工作的。让我们快速的看一下每个函数怎么工作的。\r\n### addStream\r\n\r\n用来将MediaStream添加到PeerConnection中。如果你想让别人看到你听到你，就需要这个函数。\r\n### addCandidate\r\n\r\nTODO [IceCandidates](http://stackoverflow.com/a/21071464)仅创建一次，允许其他人与你连接。\r\n### createOffer/createAnswer\r\n\r\nTODO 这两个用来初始化通话设置。\r\n### setLocalDescription和setRemoteDescription\r\n\r\nTODO 设置SDP。\r\n### PeerConnectionObserver\r\n\r\nTODO 提供这个PeerConnection事件的观察者。\r\n## 最后\r\n\r\n正如你看到的，当你对Web很熟悉时，这个Android的API是很简单直接的。使用上面的工具，你可以开发一个WebRTC的APP，数百万的设备可以直接使用。\r\n\r\nWebRTC开放给我我们所有人，对于开发者免费，对用户免费。它的使用不仅仅在视频聊天，我们也看到在医疗，文件传输甚至在游戏中都有使用。\r\n\r\n为了查看WebRTC的例子，检出appear.in在[Android](https://play.google.com/store/apps/details?id=appear.in.app&referrer=utm_source%3Dtech.appear.in%26utm_medium%3Dblog%26utm_campaign%3Dandroid-launch-may15)和[iOS](https://itunes.apple.com/app/apple-store/id878583078?pt=1259761&ct=tech.appear.in&mt=8)上。它在浏览器上和应用上都完美的工作着，一起八个人在一个房间中都是免费的，不需要安装和登陆。\r\n\r\n去吧，创建一些新的不一样的东西吧！\r\n"},{"number":3,"title":"Android 系统启动流程","created_at":"2016-11-24 07:09:15","body":"### 转载自\r\n\r\n[枫寒 - 简书](http://www.jianshu.com/users/ac4e3d0f6a81/latest_articles)，略作修改。本文包含三个部分：**综述 Android 系统启动**，**Android 的 init 进程启动过程**，**Zygote 的启动过程**。\r\n\r\n### 正文\r\n\r\n# Android 系统启动\r\n\r\n对于Android系统整个启动过程来说，基本可以划分成三个阶段：Bootloader 引导、Linux kernel 启动、Android 启动。如下的流程图可以看出三个阶段的执行顺序和联系（一张图看不懂就看三张图）。\r\n\r\n![112356615](https://cloud.githubusercontent.com/assets/21374839/20380308/35924eaa-acdc-11e6-9006-30d561fcf22f.jpg)\r\n\r\n![112356709](https://cloud.githubusercontent.com/assets/21374839/20380307/3591c4d0-acdc-11e6-9177-34a563337b36.png)\r\n\r\n![2848265-3](https://cloud.githubusercontent.com/assets/21374839/20346255/0c78c6b2-ac36-11e6-9472-2c350b89f817.png)\r\n\r\n[原图](https://cloud.githubusercontent.com/assets/21374839/20430762/3797d706-add1-11e6-97e9-1d61add0dbc2.png)\r\n![naotu baidu com_file_215b19ae3f2187344a484be8a67a4e82 token e5be85bce42717c0](https://cloud.githubusercontent.com/assets/21374839/20430762/3797d706-add1-11e6-97e9-1d61add0dbc2.png)\r\n\r\n### Bootloader 引导\r\n\r\nBootLoader是在操作系统运行之前运行的一段程序，它可以将系统的软硬件环境带到一个合适状态，为运行操作系统做好准备。它的任务就是把 OS 拉起来运行，启动 Linux 内核，我们对这一块的内容并不太注意。\r\n\r\n### Linux kernel启动\r\n\r\nLinex kernel启动后会初始化环境/驱动等，接着会启动 init的进程。\r\n\r\n#### 1.Init进程的启动\r\n\r\ninit进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序 init 的方式，启动 init 进程。\r\n\r\n启动过程是代码`system\\core\\init\\init.cpp`的 main 函数的执行过程。在函数中执行了：文件夹建立，挂载，rc文件解析，属性设置，启动服务，执行动作，socket 监听等。在rc文件解析中会启动 ServiceManager 服务和 Zygote 进程。\r\n\r\n#### 2. ServiceManager 服务\r\n\r\nServiceManager 用来管理系统中所有的 binder service，不管是本地的c++实现的还是java语言实现的都需要这个进程来统一管理，最主要的管理就是，注册添加服务，获取服务。所有的 Service 使用前都必须先在 ServiceManager 中进行注册。\r\n\r\n#### 3. Zygote 进程的启动\r\n\r\nZygote 进程启动才算建立起真正的 Android 的运行空间。不过 Init 进程不会直接启动 Zygote 进程，而是使用 app_process 命令来通过 Android Runtime 来启动，Android Runtime 会启动第一个 Davlik 虚拟机，并调用 Zygote 的 main 方法，启动服务。dir/system/core/rootdir/init.zygote32.rc：\r\n\r\n```\r\nservice zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server\r\n```\r\n\r\n### Android启动\r\n\r\n#### 1. Zygote 启动\r\n\r\n\r\nZygote 从 frameworks/base/cmds/app_process/app_main.cpp 中的 main 开始，并建立 Android Run Time。\r\n\r\n```\r\n//建立 Android runtime\r\nruntime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\r\n// 然后调用 Java 的 ZygoteInit\r\n// dir/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java\r\n// 随后\r\n//登记Listen端口\r\nregisterZygoteSocket();\r\n//启动SystemServer服务\r\nstartSystemServer();\r\n```\r\n\r\n#### 2. SystemServer启动\r\n\r\n在上一步中调用了 startSystemServer， Zygote 上 fork 了一个进程：com.android.server.SystemServer。于是 Java 中的 SystemServer 就建立起来了，SystemServer 的 main 函数中会启动一些服务：\r\n\r\n```\r\nstartBootstrapServices();\r\nstartCoreServices();\r\nstartOtherServices();\r\n```\r\n\r\n在startBootstrapServices()中看到\r\n\r\n```\r\nmActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService();\r\n```\r\n\r\nActivityManagerService.Lifecycle 是 ActivityManagerService 的静态内部类， 持有 ActivityManagerService 实例。所以 ActivityManagerService 是在这里被启动起来的。\r\n\r\n当然还有很多的其他服务（PackageManagerService、PowerManagerService、DisplayManagerService、BatteryService等）也都会被启动起来。\r\n\r\n在所有的服务启动完成后，会调用Service.systemReady()来通知各对应的服务，系统已经就绪。\r\n\r\n#### 3.ActivityManagerService启动\r\n\r\n在 ActivityManagerService 的 systemReady() 方法中有：\r\n\r\n```\r\nstartHomeActivityLocked();\r\nmStackSupervisor.startHomeActivity()\r\n```\r\n\r\n这样Home程序被启动起来，整个android的启动过程就完成了，进入用户界面。\r\n\r\n---------------\r\n\r\n<center style=\"color:red;\">霸 气 的 分 割 线</center>\r\n\r\n---------------\r\n\r\n# Android 的 init 进程启动过程\r\n\r\n### 0. 前言\r\n\r\nAndroid 中的内核启动后，kernel 会启动第一个用户级别的进程：init，它是一个由内核启动的第一个用户级进程。我们可以通过`adb shell ps | grep init`来查看到他的 pid 为 1。接下来从源码的角度看看init进程启动的时候做了什么？\r\n\r\ninit 进程的源码在 android 源码的: dir/system/core/init 目录中。我们看到该目录下有一个 Android.mk 文件，至少看到如下内容，告诉我们会生成一个 init 的的可执行文件。\r\n\r\n```\r\nLOCAL_MODULE:= init\r\ninclude $(BUILD_EXECUTABLE)\r\n```\r\n\r\n而 init 的入口 main 函数是在 init.cpp 文件中定义的。\r\n\r\n### 1. 入口\r\n\r\n#### 1. 命令行解析\r\n\r\n```\r\nif (!strcmp(basename(argv[0]), \"ueventd\")) {    \r\n      return ueventd_main(argc, argv);\r\n}\r\nif (!strcmp(basename(argv[0]), \"watchdogd\")) {    \r\n      return watchdogd_main(argc, argv);\r\n}\r\n```\r\n\r\nwatchdog 和 uevent 命令已经集成到了 init， 它们在 /sbin 目录，是一个链接文件，直接链接到 /init，所以当执行 /sbin/eventd 或 /sbin/watchdogd 时，将会进入对应的 ueventd_main 或 watchdogd_main 入口点。ueventd 守护进程负责解析 /ueventd.rc 文件，并创建相应的设备结点等。watchdogd 守护进程负责定时向 \"/dev/watchdog\" 执行写操作，以判断系统是否正常运行。这两个进程不是本文讨论的重点，所以先忽略。\r\n\r\n#### 2. 挂载根文件系统的目录\r\n\r\n```\r\nmount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\");\r\nmkdir(\"/dev/pts\", 0755);\r\nmkdir(\"/dev/socket\", 0755);\r\nmount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL);\r\nmount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC));\r\nmount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);\r\nmount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL);\r\nmknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11));\r\n```\r\n\r\n分别挂载 proc 和和 sysfs 文件系统到 /proc 和 /sys 目录\r\nclose(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); 在/dev目录创建一个空文件 .booting 来表示正在执行初始化\r\nInitKernelLogging(argv); 重定向标准输入，标准输出，标准错误输出到 /dev/null\r\nselinux_initialize(is_first_stage) 加载SELinux策略， 后面有一些初始化文件上下文的操作等\r\n\r\n#### 3. 解析 init.rc 文件\r\n\r\n```\r\nParser& parser Parser::GetInstance();\r\nparser.AddSectionParser(\"service\",std::make_unique<ServiceParser>());\r\nparser.AddSectionParser(\"on\", std::make_unique<ActionParser>());\r\nparser.AddSectionParser(\"import\", std::make_unique<ImportParser>());\r\nparser.ParseConfig(\"/init.rc\");\r\n```\r\n\r\n- 3.1 init.rc 文件是以块（section）为单位组织的，一个 section 包含多行。section 分为两大类：分别为“服务（service）”和“行为（action）”。\r\n\r\n- 3.2 “服务”块以关键字“service”开始，表示启动某个进程的方式和参数，“行为”块以关键字“on”开始，表示一堆命令的集合。每个块以关键字“service”或“on”开始，直到下一个“on”或“service”结束，中间所有行都属于这个“块”。\r\n\r\n- 3.3 上面在解析 init.rc 文件时使用了 Parser 类（在init目录下的init_parser.h中定义）， 初始化 ServiceParser 用来解析 “service”块，ActionParser 用来解析\"on\"块，ImportParser 用来解析“import”块，“import”是用来引入一个 init 配置文件，来扩展当前配置的。\r\n\r\n- 3.4 parser 解析 init.rc 文件，/init.rc 文件是 dir/system/core/rootdir/init.rc。\r\n\r\n- 3.5 dir/system/core/init/readme.txt 中对 init 文件中的所有关键字做了介绍，主要包含了 Actions, Commands, Services, Options, and Imports 等\r\n\r\n- 3.6 在 ParseConfig 解析完 init 脚本后，init会依次执行几个重要的阶段：\r\n\r\n    3.6.1 on early-init阶段\r\n    \r\n        am.QueueEventTrigger(\"early-init\"); 执行 on early-init 内容，主要包括 start ueventd 等\r\n\r\n    3.6.2. on init 阶段\r\n\r\n        am.QueueEventTrigger(\"init\"); 执行 on init 内容，主要包括 创建/挂载一些目录，以及 symlink 等\r\n\r\n    3.6.3. on charger/late-init阶段\r\n\r\n        ```\r\n         // Don't mount filesystems or start core system services in charger mode.\r\n         std::string bootmode = property_get(\"ro.bootmode\");\r\n         if (bootmode == \"charger\") {\r\n             am.QueueEventTrigger(\"charger\");\r\n         } else {\r\n             am.QueueEventTrigger(\"late-init\");\r\n         }\r\n        ```\r\n\r\n    如果是充电模式下启动 就会执行 on charger 内容， 否则执行 on late-init 内容，在 init.rc 的 on late-init 中看到很多 trigger（触发器），用于执行对应的 Action。\r\n\r\n        ```\r\n        trigger late-fs\r\n        \r\n        # Now we can mount /data. File encryption requires keymaster to decrypt\r\n        # /data, which in turn can only be loaded when system properties are present.\r\n        trigger post-fs-data\r\n        \r\n        # Load persist properties and override properties (if enabled) from /data.\r\n        trigger load_persist_props_action\r\n        \r\n        # Remove a file to wake up anything waiting for firmware.\r\n        trigger firmware_mounts_complete\r\n        \r\n        trigger early-boot\r\n        trigger boot\r\n        ```\r\n        \r\n    从最后两行可以看出，late-init 触发了on early-boot 和 on boot 两个 Action。\r\n        \r\n    3.6.4. on boot 阶段在 on boot 的最后 class_start core 会启动 class 为核心的服务，这些服务包括 ueventd、logd、healthd、adbd（disabled）、lmkd（LowMemoryKiller）、servicemanager、vold、debuggerd、surfaceflinger、bootanim（disabled）等\r\n\r\n    3.6.5. main 服务的启动\r\n\r\n    在 main 函数后面的 while 循环中，调用 execute_one_command 依次执行操作队列中的命令\r\n\r\n        ```\r\n        while (true) {\r\n            if (!waiting_for_exec) {\r\n                am.ExecuteOneCommand();\r\n                restart_processes();\r\n            }\r\n        }\r\n        ```\r\n\r\n    在 /init.rc 的开头部分\r\n        \r\n        ```\r\n        import /init.environ.rc\r\n        import /init.usb.rc\r\n        import /init.${ro.hardware}.rc\r\n        import /init.usb.configfs.rc\r\n        import /init.${ro.zygote}.rc\r\n        ```\r\n        \r\n    通过 ro.zygote 的属性 import 对应的 zygote 的 rc 文件，通过 adb shell getprop ro.zygote 查看得到 zygote64_32， 所以 import 的是 /init.zygote64_32.rc 文件，该文件中定义的 zygote 如下：\r\n    \r\n        ```\r\n        service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote\r\n        class main\r\n        priority -20\r\n        socket zygote stream 660 root system\r\n        onrestart write /sys/android_power/request_state wake\r\n        onrestart write /sys/power/state on\r\n        onrestart restart audioserver\r\n        onrestart restart cameraserver\r\n        onrestart restart media\r\n        onrestart restart netd\r\n        writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks\r\n        ```\r\n\r\n    可以看到 zygote 的 class 是 main, 它是在 on nonencrypted 时被启动的\r\n\r\n        ```\r\n        on nonencrypted\r\n            # A/B update verifier that marks a successful boot.\r\n            exec - root -- /system/bin/update_verifier nonencrypted\r\n            class_start main\r\n            class_start late_start\r\n        ```\r\n\r\n    注：但在 Android 7.0 中，对该机制做了一些改变 。\r\n    单一的init＊.rc，被拆分，服务根据其二进制文件的位置（／system，／vendor，／odm）定义到对应分区的etc／init目录中，每个服务一个 rc 文件。与该服务相关的触发器、操作等也定义在同一 rc 文件中。\r\n\r\n        /system/etc/init，包含系统核心服务的定义，如 SurfaceFlinger、MediaServer、Logcatd 等。\r\n        /vendor/etc/init， SOC 厂商针对 SOC 核心功能定义的一些服务。比如高通、MTK 某一款 SOC 的相关的服务。\r\n        /odm/etc/init，OEM/ODM 厂商如小米、华为、OPP 其产品所使用的外设以及差异化功能相关的服务。\r\n    \r\n    查看 Android 7.0 虚拟机的 /system/etc/init 如下\r\n\r\n    ![2848265-c235da5cec4a1208](https://cloud.githubusercontent.com/assets/21374839/20346629/19a1dbb0-ac38-11e6-85bf-9c9d61f8d1ce.png)\r\n\r\n    上面的 ServiceManager 这个服务也从 init.rc 中拆分出来了。\r\n\r\n#### 4. 启动完成\r\n\r\n至此，init 进程已经启动完成，一些重要的服务如 core 服务和 main 服务也都启动起来，并启动了zygote（/system/bin/app_process64）进程，zygote 初始化时会创建虚拟机，启动 SystemServer 等，它的启动过程也是非常复杂。\r\n\r\n---------------\r\n\r\n<center style=\"color:red;\">霸 气 的 分 割 线</center>\r\n\r\n---------------\r\n\r\n# Zygote 的启动过程\r\n\r\n### 0. 前言\r\n\r\n上节文章的最后说到了 init 以 service 的方式启动了 Zygote 进程。这节文章主要讲 Zygote 进程的启动流程。\r\n\r\n对于 Zygote 进程的描述如下：\r\n\r\n在 Android 中，zygote 是整个系统创建新进程的核心。Zygote 进程在内部会先启动 Dalvik 虚拟机，继而加载一些必要的系统资源和系统类，最后进入一种监听状态。在后续的运作中，当其他系统模块（比如AMS）希望创建新进程时，只需向 Zygote 进程发出请求，Zygote 进程监听到该请求后，会相应地“分裂”出新的进程，于是这个新进程在初生之时，就先天具有了自己的 Dalvik 虚拟机以及系统资源。\r\n\r\n### 1. 启动流程\r\n\r\n/init.zygote64_32.rc 文件中启动 Zygote 的内容如下：\r\n\r\n```\r\n    service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote\r\n    class main\r\n    priority -20\r\n    socket zygote stream 660 root system\r\n    onrestart write /sys/android_power/request_state wake\r\n    onrestart write /sys/power/state on\r\n    onrestart restart audioserver\r\n    onrestart restart cameraserver\r\n    onrestart restart media\r\n    onrestart restart netd\r\n    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks\r\n```\r\n\r\n在 dir/system/core/rootdir/ 目录下可以看到 init.zygote32.rc、init.zygote32_64.rc、init.zygote64.rc、init.zygote64_32.rc 等文件，这是因为 Android5.0 开始支持 64 位的编译，所以 Zygote 进程本身也有 32 位和 64 位版本。\r\n\r\n从上面定义看到Zygote进程的可执行文件是 frameworks/base/cmds/app_process/app_main.cpp。\r\n\r\n接下来分析 main 函数的流程。\r\n\r\n1.1. 创建 AppRuntime 对象\r\nAppRuntime 是在 app_process 中定义的类，继承了系统的 AndroidRuntime 类，AndroidRuntime 类的主要作用是创建和初始化虚拟机。\r\n\r\n1.2. 解析启动参数\r\n\r\n```\r\n  while (i < argc) {\r\n    const char* arg = argv[i++];\r\n    if (strcmp(arg, \"--zygote\") == 0) {\r\n        zygote = true;\r\n        niceName = ZYGOTE_NICE_NAME;\r\n    } else if (strcmp(arg, \"--start-system-server\") == 0) {\r\n        startSystemServer = true;\r\n    } else if (strcmp(arg, \"--application\") == 0) {\r\n        application = true;\r\n    } else if (strncmp(arg, \"--nice-name=\", 12) == 0) {\r\n        niceName.setTo(arg + 12);\r\n    } else if (strncmp(arg, \"--\", 2) != 0) {\r\n        className.setTo(arg);\r\n        break;\r\n    } else {\r\n        --i;\r\n        break;\r\n    }\r\n}\r\n```\r\n\r\n从 init.rc 文件中传入的参数是 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote，解析后：\r\n\r\n```\r\nzygote = true;\r\nniceName = zygoe;\r\nstartSystemServer = true;\r\n```\r\n\r\n1.3. 执行 ZygoteInit 类\r\n\r\n```\r\nif (zygote) {\r\n    runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\r\n} else if (className) {\r\n    runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote);\r\n} else {\r\n    fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\r\n    app_usage();\r\n    LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\r\n    return 10;\r\n}\r\n```\r\n\r\nZygote 经过解析参数后为 true， 所以会执行 runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\r\nAndroidRuntime 的 start 方法实现在 dir/frameworks/base/core/jni/AndroidRuntime.cpp 中，\r\n\r\n```\r\n/*\r\n\r\n * Start the Android runtime.  This involves starting the virtual machine\r\n * and calling the \"static void main(String[] args)\" method in the class\r\n * named by \"className\".\r\n *\r\n * Passes the main function two arguments, the class name and the specified\r\n * options string.\r\n */\r\nvoid AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)\r\n{\r\n    // 启动虚拟机，注册jni等\r\n    char* slashClassName = toSlashClassName(className);\r\n    jclass startClass = env->FindClass(slashClassName);\r\n    if (startClass == NULL) {\r\n    ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName);\r\n    /* keep going */\r\n    } else {\r\n        jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\",\r\n            \"([Ljava/lang/String;)V\");\r\n        if (startMeth == NULL) {\r\n            ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className);\r\n            /* keep going */\r\n        } else {\r\n            env->CallStaticVoidMethod(startClass, startMeth, strArray);\r\n\r\n#if 0\r\n        if (env->ExceptionCheck())\r\n            threadExitUncaughtException(env);\r\n#endif\r\n        }\r\n    }\r\n      ...\r\n}\r\n```\r\n\r\n这个方法会启动 Android 运行环境，意味着它会启动 Android 虚拟机，并调用参数中 className 中的 main 方法。\r\n从传入的 com.android.internal.os.ZygoteInit 类中找到 main 函数，即调用 ZygoteInit.java 类中的 main 方法。AndroidRuntime 及之前的方法都是 native 的方法，而此刻调用的 ZygoteInit.main 方法是 java 的方法，到这里我们就进入了 java 的世界。\r\n\r\n调用示意图如下：\r\n\r\n![2848265-da92b5d71fba5c28](https://cloud.githubusercontent.com/assets/21374839/20346675/53237f6a-ac38-11e6-8c00-2943629a2955.png)\r\n\r\n1.4. ZygoteInit 的 main 方法\r\n\r\nZygoteInit 定义在 dir/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 中。\r\n\r\n```\r\npublic static void main(String argv[]) {\r\n    try {\r\n        ...\r\n        registerZygoteSocket(socketName);\r\n        preload();\r\n        if (startSystemServer) {\r\n            startSystemServer(abiList, socketName);\r\n        }\r\n        runSelectLoop(abiList);\r\n        ...\r\n    } catch (MethodAndArgsCaller caller) {\r\n        caller.run();\r\n    } catch (RuntimeException ex) {\r\n        Log.e(TAG, \"Zygote died with exception\", ex);\r\n        closeServerSocket();\r\n        throw ex;\r\n    }\r\n}\r\n```\r\n\r\n主要工作:\r\n\r\n- 注册Zygote的socket监听端口，应用接收启动应用程序的消息\r\n-  调用preload()方法加载系统资源，包括预加载类，Framework资源等\r\n- 调用startSystemServer()方法启动SystemServer进程\r\n- 调用runSelectLoop()方法进入监听和接收消息循环\r\n\r\n可见SystemServer是Zygote启动的第一个进程。\r\n\r\n以上学习了 Android 系统的启动流程。\r\n"}]